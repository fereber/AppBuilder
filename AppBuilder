#!/bin/bash

_VERSION='1.0.0'

_APP_COMMON=()
_APP_ADVANCED=()
_APP_GAME=()
_APP_CODEC=()
_APP_NON_FAVORITE=()

declare -A _APP_INSTALL

_APP_COMMON+=( nautilus )                        ; _APP_INSTALL[nautilus]="--pack"
_APP_COMMON+=( gedit )                           ; _APP_INSTALL[gedit]="--pack"

_APP_ADVANCED+=( dconf-editor )                  ; _APP_INSTALL[dconf-editor]="--pack"
_APP_ADVANCED+=( gnome-tweak-tool )              ; _APP_INSTALL[gnome-tweak-tool]="--pack"

_APP_NON_FAVORITE+=( ubuntu-web-launchers )      ; _APP_INSTALL[ubuntu-web-launchers]="--pack"
_APP_NON_FAVORITE+=( gnome-characters )          ; _APP_INSTALL[gnome-characters]="--snap" # prefer main source to snap

export NEWT_COLORS="root=,black window=,lightgray title=black, button=lightgray,black actbutton=black,lightgray checkbox=black,lightgray actcheckbox=lightgray,black listbox=black,lightgray actlistbox=lightgray,black sellistbox=black,lightgray actsellistbox=lightgray,gray textbox=black,lightgray acttextbox=lightgray,black border= shadow= entry= label= helpline= roottext= emptyscale= fullscale= disentry= compactbutton= "

_dimension() {
  LINES=""; LINES=$(tput lines); COLUMNS=""; COLUMNS=$(tput cols)
}

# Check if one element value exists in a list or array
#
_contains() {
  local _list=(${*:2})
  for _element in "${_list[@]:-}"; do [[ "${_element}" == "${1}" ]] && return 0; done
  return 1
}

# Version controll
#
_check_version() {
  test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

# Cheking System
#
_check_os_and_distro() {
  # Check OS
  [[ $(uname) != "Linux" ]] && printf "Sorry! This script only suports Linux!\nExiting...\n" && exit 1
  # Check distribution
  if [[ $(which lsb_release &>/dev/null; echo $?) -ne 0 ]]; then
    printf "Sorry! Can't be checked which distribution you are using!\nExiting...\n"
    exit 1
  else
    _DISTRIB_ID=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_ID | cut -d= -f2); _DISTRIB_CODENAME=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_CODENAME | cut -d= -f2); _UBUNTU_CODENAME=$(cat /etc/*-release 2>/dev/null | grep UBUNTU_CODENAME | cut -d= -f2); _DISTRIB_DESCRIPTION=$(lsb_release -ds)
    if ! lsb_release -ds | grep -qE '(Ubuntu|Mint|elementary|Debian)'; then
      if ! (whiptail --title "Warning" --yesno "You are using a distribution that may not be full compatible with this script. Are you sure you want to continue?" 10 50); then
        exit 1
      fi
    fi
  fi
}

# Check system environment
#
_check_desktop() {
  # Check chassis
  if [[ $(hostnamectl | grep Chassis | awk '{print $2}') == "vm" ]]; then
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on desktop environment.\nIt's not recommended to run on server environment."
    return 1
  else
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on server environment.\nIt's not recommended to run on desktop environment."
    return 0
  fi
}

# Check timezone
#
_check_timezone() {
  _CUR_TIMEZONE="$(timedatectl | grep -e 'Time zone' | tr -s " " | cut -d ' ' -f 4)"
  if [[ "${_CUR_TIMEZONE}" == "Etc/UTC" ]] || [[ "${_CUR_TIMEZONE}" == "" ]]; then
    printf "Current timezone on system: %s\n" "${_CUR_TIMEZONE}"
    read -p "Do you want to set a new timezone? [y/n] " REPLY
    if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
      local _TIMEZONE=$(whiptail --inputbox "\nEnter the new time zone (format: Continent/City):" 8 75 --title "Timezone Setting" 3>&1 1>&2 2>&3)
      if [[ $(timedatectl list-timezones | grep "${_TIMEZONE}" &> /dev/null; echo $?) != "0" ]]; then
        _error "invalid timezone --'${_TIMEZONE}'"
      else
        sudo timedatectl set-timezone "${_TIMEZONE}" && whiptail --title "Success" --msgbox "The timezone changed to ${_TIMEZONE}." 7 80
      fi
    fi
  else
    return 0
  fi
}

# Check git config
#
_check_git_config() {
  if hash git 2>/dev/null; then
    if [[ -z "$(git config user.name)" ]] || [[ -z "$(git config user.email)" ]]; then
      printf "Git is installed, but missing your Git identity.\nThis is important because every Git commit uses this information.\n"
      read -p "Do you want to set your user name and email address? [y/n] " REPLY
      if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
        local _USER_GIT=$(whiptail --inputbox "\nEnter the name for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        local _EMAIL_GIT=$(whiptail --inputbox "\nEnter the e-mai adress for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        git config --global user.name "${_USER_GIT}"
        git config --global user.email "${_EMAIL_GIT}"
      fi
    fi
  fi
}

# Determine if a package exists
#
_check_package_exists() {
  if [ $# -gt 2 ]; then
    echo "Error: Too many arguments in ${FUNCNAME[0]}() function!"
    exit 1
  elif [ $# -eq 2 ]; then
    if [ "${1}" != "--print-status" ]; then
      echo "Error: Unrecognized option in ${FUNCNAME[0]}() function: \`${1}\`!"
      exit 1
    fi
    local _PACKAGE=${2}
  else
    local _PACKAGE=${1}
  fi
  local _COUNT=0; local _SOURCE=(); local _INSTALL_STATUS="✔" # https://coolsymbol.com/
  if [[ $(dpkg-query -W --showformat='${Status}\n' ${_PACKAGE} 2>/dev/null | grep "install ok installed" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    _SOURCE+=( pack )
  fi
  # Software Source: AppImage
  if [[ $(type -P "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    if [ "$(type -P "${_PACKAGE}")" == "/usr/bin/${_PACKAGE}" ]; then
      if ! _contains "pack" "${_SOURCE[*]}"; then
        _SOURCE+=( pack )
      fi
    fi
    if [ "$(type -P "${_PACKAGE}")" == "$HOME/.local/bin/${_PACKAGE}" ]; then
      _SOURCE+=( appimg )
    fi
    if [ -f "/usr/local/share/${_PACKAGE}/Makefile" ]; then
      _SOURCE+=( complied )
    fi
  fi
  if hash snapd 2>/dev/null; then
    if [[ $(snap list | grep "^${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( snap )
    fi
  fi
  # Software Source: Flat Store
  if hash flatpak 2>/dev/null; then
    if [[ $(flatpak list | grep "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( flat )
    fi
  fi
  if [ "${1}" == "--print-status" ]; then
    if [[ "${_COUNT}" -eq 0 ]]; then
      _INSTALL_STATUS="✖"
      _SOURCE+=( " -- " )
    fi
    # Print status and info of sources
    (IFS="+$IFS"; printf '%s (%s)' "${_INSTALL_STATUS}" "${_SOURCE[*]}")
  else
    if [[ "${_COUNT}" -gt 0 ]]; then
      echo 0
    else
      echo 1
    fi
  fi
}

# Script dependencies
#
_check_dependencies() {
  # Depends packages
  local _DEP_PACK=("whiptail wget curl git"); local _REQ_PACK=""; local _MISSING_PACK="";
  for _MISSING_PACK in ${_DEP_PACK}; do
    [[ $(_check_package_exists "${_MISSING_PACK}") != 0 ]] && _REQ_PACK+=("${_MISSING_PACK}")
  done
  if [ -n "${_REQ_PACK}" ]; then
    printf "This script requires some packages, but the following are not present on your system.\n"
    printf "  * %s\n" "${_REQ_PACK[@]}"
    read -p 'Would you like to install these packages to continue? [Y/n] ' REPLY
    case $REPLY in
      [Yy]* )
        cmd_install --pack "${_REQ_PACK[*]}" ;;
      [Nn]* )
        echo "Exiting..." && exit ;;
      * )
        echo "Sorry, try again." && _check_dependencies ;;
    esac
  fi
}

# Exit with an error and print the specified message
#
_error() {
  printf "\n$(tput bold)$(tput setaf 1) ✖ Error: %s$(tput sgr0)\n\n" "${*}" 1>&2
  exit 1
}

# Get commands and command functions
#
_get_command_functions() {
  local _function_list=($(printf "%s" "$(declare -F)" | sed -e "s/declare -f //g"))
  for _name in "${_function_list[@]}"; do
    if [[ "${_name}" =~ ^cmd_(.*) ]]; then
      _CMD_FUNCTIONS+=("${_name}")
      _CMD_ALLOWED+=($(printf "%s" "${_name}" | sed -e "s/cmd_//g"))
    fi
  done
}

# The primary function for starting the program.
#
_main() {
  # Checking things
  _check_os_and_distro
  _check_dependencies
  _check_timezone
  _check_git_config

  # Load allowed command
  _get_command_functions

  # Default command
  [[ -z "${_CMD:-}" ]] && _CMD=${1:-menu}

  if ( [[ -n "${_CMD}" ]] && _contains "${_CMD}" "${_CMD_ALLOWED[*]}"); then
    # If the command is defined, run its function...
    cmd_"${_CMD}" "${@:2}"
  else # If the command is not defined, run this...

    # Options parser
    _OPTS=$(getopt --options h,u,c,i,e,s,v --long help,debug,update,clean,info,error,setting,version --name "$(basename "${0}")" -- "${@}")
    if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
    eval set -- "${_OPTS}"

    while true ; do
      case "${1}" in
        -h|--help)     cmd_help ${_CMD} ; shift ;;
        --debug)   set -x ; _DEBUG=true ; shift ;;
        -u|--update)  _system_update    ; shift ;;
        -c|--clean)   _system_cleanup   ; shift ;;
        -i|--info)    _system_info      ; shift ;;
        -e|--error)   _system_error     ; shift ;;
        -s|--setting) _system_settings  ; shift ;;
        -v|--version)
          printf "%s\n" "${_VERSION}"
          shift ;;
        --) shift ; break ;;
        *) _error "internal option error '${1}'"
      esac
    done
  fi
}

# COMMAND: Help
#
# Usage (optional):
#   ```
#   _HELP[command]=$(cat << HELPSOMETHING
#     Usage: ...
#   HELPSOMETHING
#   )
#
#   cmd_command() {
#     echo -n
#   }
#   ```
# Declare command in array without `cmd_` prefix and use in name of function with `cmd_` prefix
#
declare -A _HELP[help]=$(cat << HELPCMD
The menu command displays the help information for '$(basename "${0}")' or
a specified command.

Usage:
  $(basename "${0}") -h | --help
  $(basename "${0}") help <command>

HELPCMD
)

cmd_help() {
  if ( [[ $# -gt 0 ]] && [[ ! "${1}" =~ ^- ]] ); then
    # Help to specific command
    if _contains "${1}" "${_CMD_ALLOWED[*]}"; then
      if _contains "${1}" "${!_HELP[*]}"; then
        printf "%b\n\n" "${_HELP[${1}]}"
      else
        printf "No additional information for '%s'\n" "${1}"
      fi
    else
      printf "Sorry, '%s' is not an allowed command!\n\nAllowed command(s):\n" "${1}"
      printf " %s\n" "${_CMD_ALLOWED[@]}"
    fi
  else
    cat << HELPDESKTOP
The $(basename "$0") is a post install script to help building and setting your system.

  Usage:
    Run '$(basename "${0}")' without options and arguments in interactive mode
    $(basename "${0}") [commands] [options] [<arguments>...]

  Options:
    -u, --update        Update system
    -c, --clean         Cleanup system
    -s, --setting       Configure system
    -i, --info          Display system information
    -e, --error         Display error information (\`dmesg\`)
    -v, --version       Print script version number
    -h, --help          Display this help
        --debug         Run debug mode

  Commands:
    $(printf " %s" "${_CMD_ALLOWED[@]}")

For more information about a command, run '$(basename "${0}") help <command>'
HELPDESKTOP
  fi
  exit
}

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

cmd_menu(){
  _dimension
  _MENU_MAIN=$(whiptail --title "Main Menu" --menu "\n   What would you like to do? Choose an option..." --cancel-button "Quit" --notags $LINES $COLUMNS $(( $LINES - 10 )) \
      "cmd_menu" "System:" \
      "_system_update" "  Update" \
      "_system_cleanup" "  Cleaning" \
      "_system_info" "  Print Info" \
      "_system_error" "  Print Error" \
      "cmd_menu" "" \
      "cmd_menu" "Installing Applications:" \
      "_menu_sub install _APP_COMMON 'Commonly Used Application' 'Install'" "  Commonly Used ▸" \
      "_menu_sub install _APP_ADVANCED 'Installing Advanced Application' 'Install'" "  Advanced ▸" \
      "_menu_sub install _APP_GAME 'Installing Games' 'Install'" "  Games ▸" \
      "_menu_sub install _APP_CODEC 'Installing Codecs' 'Install'" "  Codecs ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Removing Applications:" \
      "_menu_sub remove _APP_COMMON 'Removing Commonly Used Application' 'Uninstall'" "  Commonly Used ▸" \
      "_menu_sub remove _APP_ADVANCED 'Removing Advanced Application' 'Uninstall'" "  Advanced ▸" \
      "_menu_sub remove _APP_GAME 'Removing Games' 'Uninstall'" "  Games ▸" \
      "_menu_sub remove _APP_CODEC 'Removing Codecs' 'Uninstall'" "  Codecs ▸" \
      "_menu_sub remove _APP_NON_FAVORITE 'Removing Non-favorite Apps' 'Uninstall'" "  Non-favorite Apps ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Settings:" \
      "_menu_show_desc" "  Show App Info" \
      "sudo update-alternatives --config java" "  Config Java" \
      "_system_settings" "  Setting System" \
    3>&1 1>&2 2>&3)
  if [ $? = 0 ]; then
    ${_MENU_MAIN}
  else
    echo "Bye!"
    exit 0
  fi
}

# Helps to build a whiptail checklist for applications
#
# Args:
#   $1 (required): install or remove
#   $2 (required): name of array
#
# Return:
#   Checklist for whiptail submenu into ${_APP_LIST[@]}
#
_menu_checking_list() {
  # Clear the previous list and create a new updated one
  unset _APP_LIST
  # Set list array
  _LIST_ARRAY="$2[@]"
  # Description for package
  _APP_DESC=""
  # Get length of list array for steps in process
  local _STEP=0; local _LIST_LENGTH=$(echo "${!_LIST_ARRAY}" | wc -w)
  # Build the list
  local _PACKAGE=""
  for _PACKAGE in "${!_LIST_ARRAY}"; do
    # Print package's description as well
    if [[ "${_SHOW_DESC}" -eq 1 ]]; then
      if [[ $(apt-cache show "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
        _APP_DESC=" -$(apt-cache show "${_PACKAGE}" | grep "Description-en" | cut -d: -f 2)" || true
      fi
    fi

    # Set package install status
    _install_status="$(_check_package_exists --print-status "${_PACKAGE}")"

    #Set checked status
    _install_list_check="OFF"
    _remove_list_check="OFF"

    # Set, if app is present on the 'non-favorite list'
    if _contains "${_PACKAGE}" "${_APP_NON_FAVORITE[@]}"; then
      _mark_non_favorite=" ☠  "
      [[ "${_install_status}" != "✖ ( -- )" ]] && _remove_list_check="ON"
    else
      _mark_non_favorite=""
    fi

    # Create whiptail commands
    if [[ "${1}" == "install" ]]; then
      _APP_LIST+=("cmd_install --app ${_PACKAGE} ${_APP_INSTALL[$_PACKAGE]}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_install_list_check})
    elif [[ "${1}" == "remove" ]]; then
      _APP_LIST+=("cmd_remove --app ${_PACKAGE}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_remove_list_check})
    else
      echo "Error line $LINENO: Menu command is wrong!"; exit
    fi

    # Progress while building the list
    # if [[ "${_SHOW_DESC}" -eq 1 ]]; then
    (( _STEP+=$(( 100 / ${_LIST_LENGTH} +1 )) ))
    echo XXX
    echo $(( $_STEP ))
    echo -e "\nUpdating package information: ${_PACKAGE}"
    echo XXX
    # fi
    # done  > >([[ "${_SHOW_DESC}" -eq 1 ]] && whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
  done > >(whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
}

# Whiptail: Submenu for actions
#
# Usage:
#   _menu_sub install _APP_COMMON 'Installing Commonly Used Application' 'Install'
#
# Args:
#   $1 (required): install or remove
#   $2 (required): Name of array
#   $3 (required): Checklit title
#   $4 (required): Checklist OK button text
#
# Return:
#   Whiptail checklist, where can you start the command for installing or removing
#
_menu_sub() {
  _dimension
  # Keep it for the return
  _preserved_command="${@}"
  eval set -- "${@}"
  # Build a list
  _menu_checking_list "${@}"
  # Checklist
  _CHECK_LIST=$(whiptail --title "${3}" --checklist "\n   Choose one or more apps to ${1}...\n\n   ✔ installed (sources)\n   ✖ not installed\n   ☠ non-favorite\n" \
      --separate-output --cancel-button "Back to Main Menu" --ok-button "${4}" --notags \
      $LINES $COLUMNS $(( $LINES - 14 )) \
      "${_APP_LIST[@]}" \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    i=0
    while read line; do
      _SELECTED_APPS[${i}]=${line}
      i=$(($i+1))
    done <<< "${_CHECK_LIST}"
    if [[ -z "${_SELECTED_APPS[@]}" ]]; then
      whiptail --title "Info" --yes-button "Back" --no-button "Quit" --yesno "Nothing selected, so nothing happened!" 7 45 || exit
    else
      for _MENU_SUB in "${_SELECTED_APPS[@]}"; do
        ${_MENU_SUB}
      done
      if [[ -z "${_SCRIPT_MESSAGES[@]}" ]]; then
        whiptail --title "Success" --yes-button "Back to List" --no-button "Quit" --yesno "The selected application(s) has been ${1}ed." 7 53 || exit
      else
        # Print message
        whiptail --scrolltext --title "Script Messages" --yes-button "OK" --no-button "Quit" --yesno "$(printf "%b\n" "${_SCRIPT_MESSAGES[@]}")" 10 75 || exit
      fi
    fi
    _menu_sub "${_preserved_command}"
  else
    cmd_menu
  fi
}

# Whiptail: Package's description settings
#
# Return:
#   Whiptail radiolist
#
_menu_show_desc() {
  if [[ "$_SHOW_DESC" == 1 ]]; then
    _SHOW_DESC_ENABLE="ON"; _SHOW_DESC_DISABLE="OFF"
  else
    _SHOW_DESC_ENABLE="OFF"; _SHOW_DESC_DISABLE="ON"
  fi
  _SHOW_DESC_OPTIONS=$( whiptail --notags --title "Show Packages' Description" --radiolist "\nDisplay information of applications in selection menus. Enabling slows down script execution!" 10 65 2 \
      "1" "Enable" $_SHOW_DESC_ENABLE \
      "0" "Disable (default)" $_SHOW_DESC_DISABLE \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    _SHOW_DESC=$_SHOW_DESC_OPTIONS
  fi
  cmd_menu
}

# System updating
#
_system_update() {
  # Refresh repository...
  printf "Please wait... "
  if hash flatpak 2>/dev/null; then
    flatpak update
  fi
  sudo apt update -qq

  # Upgrading packages if necessary
  if [[ $(LANG=C apt-get upgrade -s | grep -P '^\d+ upgraded'| cut -d" " -f1) != 0 ]]; then
    sudo apt upgrade -y
  fi

  # Install translations if language support is not installed completely
  if [[ -n "$(check-language-support)" ]]; then
    sudo apt install -y $(check-language-support)
  fi
}

# System cleaning
#
_system_cleanup() {
  # Remove leftover config files
  if [[ -z "$(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)" ]]; then
    printf "There aren't leftover config files.\n"
  else
    printf "Remove leftover config files:\n"
    sudo dpkg --purge $(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)
  fi

  # Flatpak unused applications
  if hash flatpak 2>/dev/null; then
    printf "Unused Flatpak package(s)... "
    flatpak uninstall -y --unused
  fi

  # Clean packages cache
  sudo apt clean

  # Remove orphaned packages
  if [[ $(LANG=C apt-get autoremove -s | grep -P '^\d+ upgraded'| cut -d" " -f6) -ne 0 ]]; then
    sudo apt autoremove -y -qq
  fi
}

# Call the `_main` function after everything has been defined
#
_main "$@"
