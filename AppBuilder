#!/bin/bash

_VERSION='1.0.0'

_APP_COMMON=()
_APP_ADVANCED=()
_APP_GAME=()
_APP_CODEC=()
_APP_NON_FAVORITE=()

declare -A _APP_INSTALL

_APP_COMMON+=( nautilus )                        ; _APP_INSTALL[nautilus]="--pack"
_APP_COMMON+=( gedit )                           ; _APP_INSTALL[gedit]="--pack"

_APP_ADVANCED+=( dconf-editor )                  ; _APP_INSTALL[dconf-editor]="--pack"
_APP_ADVANCED+=( gnome-tweak-tool )              ; _APP_INSTALL[gnome-tweak-tool]="--pack"

_APP_NON_FAVORITE+=( ubuntu-web-launchers )      ; _APP_INSTALL[ubuntu-web-launchers]="--pack"
_APP_NON_FAVORITE+=( gnome-characters )          ; _APP_INSTALL[gnome-characters]="--snap" # prefer main source to snap

export NEWT_COLORS="root=,black window=,lightgray title=black, button=lightgray,black actbutton=black,lightgray checkbox=black,lightgray actcheckbox=lightgray,black listbox=black,lightgray actlistbox=lightgray,black sellistbox=black,lightgray actsellistbox=lightgray,gray textbox=black,lightgray acttextbox=lightgray,black border= shadow= entry= label= helpline= roottext= emptyscale= fullscale= disentry= compactbutton= "

_dimension() {
  LINES=""; LINES=$(tput lines); COLUMNS=""; COLUMNS=$(tput cols)
}

# Check if one element value exists in a list or array
#
_contains() {
  local _list=(${*:2})
  for _element in "${_list[@]:-}"; do [[ "${_element}" == "${1}" ]] && return 0; done
  return 1
}

# Version controll
#
_check_version() {
  test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

# Cheking System
#
_check_os_and_distro() {
  # Check OS
  [[ $(uname) != "Linux" ]] && printf "Sorry! This script only suports Linux!\nExiting...\n" && exit 1
  # Check distribution
  if [[ $(which lsb_release &>/dev/null; echo $?) -ne 0 ]]; then
    printf "Sorry! Can't be checked which distribution you are using!\nExiting...\n"
    exit 1
  else
    _DISTRIB_ID=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_ID | cut -d= -f2); _DISTRIB_CODENAME=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_CODENAME | cut -d= -f2); _UBUNTU_CODENAME=$(cat /etc/*-release 2>/dev/null | grep UBUNTU_CODENAME | cut -d= -f2); _DISTRIB_DESCRIPTION=$(lsb_release -ds)
    if ! lsb_release -ds | grep -qE '(Ubuntu|Mint|elementary|Debian)'; then
      if ! (whiptail --title "Warning" --yesno "You are using a distribution that may not be full compatible with this script. Are you sure you want to continue?" 10 50); then
        exit 1
      fi
    fi
  fi
}

# Check system environment
#
_check_desktop() {
  # Check chassis
  if [[ $(hostnamectl | grep Chassis | awk '{print $2}') == "vm" ]]; then
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on desktop environment.\nIt's not recommended to run on server environment."
    return 1
  else
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on server environment.\nIt's not recommended to run on desktop environment."
    return 0
  fi
}

# Check timezone
#
_check_timezone() {
  _CUR_TIMEZONE="$(timedatectl | grep -e 'Time zone' | tr -s " " | cut -d ' ' -f 4)"
  if [[ "${_CUR_TIMEZONE}" == "Etc/UTC" ]] || [[ "${_CUR_TIMEZONE}" == "" ]]; then
    printf "Current timezone on system: %s\n" "${_CUR_TIMEZONE}"
    read -p "Do you want to set a new timezone? [y/n] " REPLY
    if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
      local _TIMEZONE=$(whiptail --inputbox "\nEnter the new time zone (format: Continent/City):" 8 75 --title "Timezone Setting" 3>&1 1>&2 2>&3)
      if [[ $(timedatectl list-timezones | grep "${_TIMEZONE}" &> /dev/null; echo $?) != "0" ]]; then
        _error "invalid timezone --'${_TIMEZONE}'"
      else
        sudo timedatectl set-timezone "${_TIMEZONE}" && whiptail --title "Success" --msgbox "The timezone changed to ${_TIMEZONE}." 7 80
      fi
    fi
  else
    return 0
  fi
}

# Check git config
#
_check_git_config() {
  if hash git 2>/dev/null; then
    if [[ -z "$(git config user.name)" ]] || [[ -z "$(git config user.email)" ]]; then
      printf "Git is installed, but missing your Git identity.\nThis is important because every Git commit uses this information.\n"
      read -p "Do you want to set your user name and email address? [y/n] " REPLY
      if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
        local _USER_GIT=$(whiptail --inputbox "\nEnter the name for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        local _EMAIL_GIT=$(whiptail --inputbox "\nEnter the e-mai adress for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        git config --global user.name "${_USER_GIT}"
        git config --global user.email "${_EMAIL_GIT}"
      fi
    fi
  fi
}

# Determine if a package exists
#
_check_package_exists() {
  if [ $# -gt 2 ]; then
    echo "Error: Too many arguments in ${FUNCNAME[0]}() function!"
    exit 1
  elif [ $# -eq 2 ]; then
    if [ "${1}" != "--print-status" ]; then
      echo "Error: Unrecognized option in ${FUNCNAME[0]}() function: \`${1}\`!"
      exit 1
    fi
    local _PACKAGE=${2}
  else
    local _PACKAGE=${1}
  fi
  local _COUNT=0; local _SOURCE=(); local _INSTALL_STATUS="✔" # https://coolsymbol.com/
  if [[ $(dpkg-query -W --showformat='${Status}\n' ${_PACKAGE} 2>/dev/null | grep "install ok installed" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    _SOURCE+=( pack )
  fi
  # Software Source: AppImage
  if [[ $(type -P "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    if [ "$(type -P "${_PACKAGE}")" == "/usr/bin/${_PACKAGE}" ]; then
      if ! _contains "pack" "${_SOURCE[*]}"; then
        _SOURCE+=( pack )
      fi
    fi
    if [ "$(type -P "${_PACKAGE}")" == "$HOME/.local/bin/${_PACKAGE}" ]; then
      _SOURCE+=( appimg )
    fi
    if [ -f "/usr/local/share/${_PACKAGE}/Makefile" ]; then
      _SOURCE+=( complied )
    fi
  fi
  if hash snapd 2>/dev/null; then
    if [[ $(snap list | grep "^${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( snap )
    fi
  fi
  # Software Source: Flat Store
  if hash flatpak 2>/dev/null; then
    if [[ $(flatpak list | grep "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( flat )
    fi
  fi
  if [ "${1}" == "--print-status" ]; then
    if [[ "${_COUNT}" -eq 0 ]]; then
      _INSTALL_STATUS="✖"
      _SOURCE+=( " -- " )
    fi
    # Print status and info of sources
    (IFS="+$IFS"; printf '%s (%s)' "${_INSTALL_STATUS}" "${_SOURCE[*]}")
  else
    if [[ "${_COUNT}" -gt 0 ]]; then
      echo 0
    else
      echo 1
    fi
  fi
}

# Script dependencies
#
_check_dependencies() {
  # Depends packages
  local _DEP_PACK=("whiptail wget curl git"); local _REQ_PACK=""; local _MISSING_PACK="";
  for _MISSING_PACK in ${_DEP_PACK}; do
    [[ $(_check_package_exists "${_MISSING_PACK}") != 0 ]] && _REQ_PACK+=("${_MISSING_PACK}")
  done
  if [ -n "${_REQ_PACK}" ]; then
    printf "This script requires some packages, but the following are not present on your system.\n"
    printf "  * %s\n" "${_REQ_PACK[@]}"
    read -p 'Would you like to install these packages to continue? [Y/n] ' REPLY
    case $REPLY in
      [Yy]* )
        cmd_install --pack "${_REQ_PACK[*]}" ;;
      [Nn]* )
        echo "Exiting..." && exit ;;
      * )
        echo "Sorry, try again." && _check_dependencies ;;
    esac
  fi
}

# Exit with an error and print the specified message
#
_error() {
  printf "\n$(tput bold)$(tput setaf 1) ✖ Error: %s$(tput sgr0)\n\n" "${*}" 1>&2
  exit 1
}

# Get commands and command functions
#
_get_command_functions() {
  local _function_list=($(printf "%s" "$(declare -F)" | sed -e "s/declare -f //g"))
  for _name in "${_function_list[@]}"; do
    if [[ "${_name}" =~ ^cmd_(.*) ]]; then
      _CMD_FUNCTIONS+=("${_name}")
      _CMD_ALLOWED+=($(printf "%s" "${_name}" | sed -e "s/cmd_//g"))
    fi
  done
}

# The primary function for starting the program.
#
_main() {
  # Checking things
  _check_os_and_distro
  _check_dependencies
  _check_timezone
  _check_git_config

  # Load allowed command
  _get_command_functions

  # Default command
  [[ -z "${_CMD:-}" ]] && _CMD=${1:-menu}

  if ( [[ -n "${_CMD}" ]] && _contains "${_CMD}" "${_CMD_ALLOWED[*]}"); then
    # If the command is defined, run its function...
    cmd_"${_CMD}" "${@:2}"
  else # If the command is not defined, run this...

    # Options parser
    _OPTS=$(getopt --options h,u,c,i,e,s,v --long help,debug,update,clean,info,error,setting,version --name "$(basename "${0}")" -- "${@}")
    if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
    eval set -- "${_OPTS}"

    while true ; do
      case "${1}" in
        -h|--help)     cmd_help ${_CMD} ; shift ;;
        --debug)   set -x ; _DEBUG=true ; shift ;;
        -u|--update)  _system_update    ; shift ;;
        -c|--clean)   _system_cleanup   ; shift ;;
        -i|--info)    _system_info      ; shift ;;
        -e|--error)   _system_error     ; shift ;;
        -s|--setting) _system_settings  ; shift ;;
        -v|--version)
          printf "%s\n" "${_VERSION}"
          shift ;;
        --) shift ; break ;;
        *) _error "internal option error '${1}'"
      esac
    done
  fi
}

# COMMAND: Help
#
# Usage (optional):
#   ```
#   _HELP[command]=$(cat << HELPSOMETHING
#     Usage: ...
#   HELPSOMETHING
#   )
#
#   cmd_command() {
#     echo -n
#   }
#   ```
# Declare command in array without `cmd_` prefix and use in name of function with `cmd_` prefix
#
declare -A _HELP[help]=$(cat << HELPCMD
The menu command displays the help information for '$(basename "${0}")' or
a specified command.

Usage:
  $(basename "${0}") -h | --help
  $(basename "${0}") help <command>

HELPCMD
)

cmd_help() {
  if ( [[ $# -gt 0 ]] && [[ ! "${1}" =~ ^- ]] ); then
    # Help to specific command
    if _contains "${1}" "${_CMD_ALLOWED[*]}"; then
      if _contains "${1}" "${!_HELP[*]}"; then
        printf "%b\n\n" "${_HELP[${1}]}"
      else
        printf "No additional information for '%s'\n" "${1}"
      fi
    else
      printf "Sorry, '%s' is not an allowed command!\n\nAllowed command(s):\n" "${1}"
      printf " %s\n" "${_CMD_ALLOWED[@]}"
    fi
  else
    cat << HELPDESKTOP
The $(basename "$0") is a post install script to help building and setting your system.

  Usage:
    Run '$(basename "${0}")' without options and arguments in interactive mode
    $(basename "${0}") [commands] [options] [<arguments>...]

  Options:
    -u, --update        Update system
    -c, --clean         Cleanup system
    -s, --setting       Configure system
    -i, --info          Display system information
    -e, --error         Display error information (\`dmesg\`)
    -v, --version       Print script version number
    -h, --help          Display this help
        --debug         Run debug mode

  Commands:
    $(printf " %s" "${_CMD_ALLOWED[@]}")

For more information about a command, run '$(basename "${0}") help <command>'
HELPDESKTOP
  fi
  exit
}

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

cmd_menu(){
  _dimension
  _MENU_MAIN=$(whiptail --title "Main Menu" --menu "\n   What would you like to do? Choose an option..." --cancel-button "Quit" --notags $LINES $COLUMNS $(( $LINES - 10 )) \
      "cmd_menu" "System:" \
      "_system_update" "  Update" \
      "_system_cleanup" "  Cleaning" \
      "_system_info" "  Print Info" \
      "_system_error" "  Print Error" \
      "cmd_menu" "" \
      "cmd_menu" "Installing Applications:" \
      "_menu_sub install _APP_COMMON 'Commonly Used Application' 'Install'" "  Commonly Used ▸" \
      "_menu_sub install _APP_ADVANCED 'Installing Advanced Application' 'Install'" "  Advanced ▸" \
      "_menu_sub install _APP_GAME 'Installing Games' 'Install'" "  Games ▸" \
      "_menu_sub install _APP_CODEC 'Installing Codecs' 'Install'" "  Codecs ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Removing Applications:" \
      "_menu_sub remove _APP_COMMON 'Removing Commonly Used Application' 'Uninstall'" "  Commonly Used ▸" \
      "_menu_sub remove _APP_ADVANCED 'Removing Advanced Application' 'Uninstall'" "  Advanced ▸" \
      "_menu_sub remove _APP_GAME 'Removing Games' 'Uninstall'" "  Games ▸" \
      "_menu_sub remove _APP_CODEC 'Removing Codecs' 'Uninstall'" "  Codecs ▸" \
      "_menu_sub remove _APP_NON_FAVORITE 'Removing Non-favorite Apps' 'Uninstall'" "  Non-favorite Apps ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Settings:" \
      "_menu_show_desc" "  Show App Info" \
      "sudo update-alternatives --config java" "  Config Java" \
      "_system_settings" "  Setting System" \
    3>&1 1>&2 2>&3)
  if [ $? = 0 ]; then
    ${_MENU_MAIN}
  else
    echo "Bye!"
    exit 0
  fi
}

# Helps to build a whiptail checklist for applications
#
# Args:
#   $1 (required): install or remove
#   $2 (required): name of array
#
# Return:
#   Checklist for whiptail submenu into ${_APP_LIST[@]}
#
_menu_checking_list() {
  # Clear the previous list and create a new updated one
  unset _APP_LIST
  # Set list array
  _LIST_ARRAY="$2[@]"
  # Description for package
  _APP_DESC=""
  # Get length of list array for steps in process
  local _STEP=0; local _LIST_LENGTH=$(echo "${!_LIST_ARRAY}" | wc -w)
  # Build the list
  local _PACKAGE=""
  for _PACKAGE in "${!_LIST_ARRAY}"; do
    # Print package's description as well
    if [[ "${_SHOW_DESC}" -eq 1 ]]; then
      if [[ $(apt-cache show "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
        _APP_DESC=" -$(apt-cache show "${_PACKAGE}" | grep "Description-en" | cut -d: -f 2)" || true
      fi
    fi

    # Set package install status
    _install_status="$(_check_package_exists --print-status "${_PACKAGE}")"

    #Set checked status
    _install_list_check="OFF"
    _remove_list_check="OFF"

    # Set, if app is present on the 'non-favorite list'
    if _contains "${_PACKAGE}" "${_APP_NON_FAVORITE[@]}"; then
      _mark_non_favorite=" ☠  "
      [[ "${_install_status}" != "✖ ( -- )" ]] && _remove_list_check="ON"
    else
      _mark_non_favorite=""
    fi

    # Create whiptail commands
    if [[ "${1}" == "install" ]]; then
      _APP_LIST+=("cmd_install --app ${_PACKAGE} ${_APP_INSTALL[$_PACKAGE]}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_install_list_check})
    elif [[ "${1}" == "remove" ]]; then
      _APP_LIST+=("cmd_remove --app ${_PACKAGE}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_remove_list_check})
    else
      echo "Error line $LINENO: Menu command is wrong!"; exit
    fi

    # Progress while building the list
    # if [[ "${_SHOW_DESC}" -eq 1 ]]; then
    (( _STEP+=$(( 100 / ${_LIST_LENGTH} +1 )) ))
    echo XXX
    echo $(( $_STEP ))
    echo -e "\nUpdating package information: ${_PACKAGE}"
    echo XXX
    # fi
    # done  > >([[ "${_SHOW_DESC}" -eq 1 ]] && whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
  done > >(whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
}

# Whiptail: Submenu for actions
#
# Usage:
#   _menu_sub install _APP_COMMON 'Installing Commonly Used Application' 'Install'
#
# Args:
#   $1 (required): install or remove
#   $2 (required): Name of array
#   $3 (required): Checklit title
#   $4 (required): Checklist OK button text
#
# Return:
#   Whiptail checklist, where can you start the command for installing or removing
#
_menu_sub() {
  _dimension
  # Keep it for the return
  _preserved_command="${@}"
  eval set -- "${@}"
  # Build a list
  _menu_checking_list "${@}"
  # Checklist
  _CHECK_LIST=$(whiptail --title "${3}" --checklist "\n   Choose one or more apps to ${1}...\n\n   ✔ installed (sources)\n   ✖ not installed\n   ☠ non-favorite\n" \
      --separate-output --cancel-button "Back to Main Menu" --ok-button "${4}" --notags \
      $LINES $COLUMNS $(( $LINES - 14 )) \
      "${_APP_LIST[@]}" \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    i=0
    while read line; do
      _SELECTED_APPS[${i}]=${line}
      i=$(($i+1))
    done <<< "${_CHECK_LIST}"
    if [[ -z "${_SELECTED_APPS[@]}" ]]; then
      whiptail --title "Info" --yes-button "Back" --no-button "Quit" --yesno "Nothing selected, so nothing happened!" 7 45 || exit
    else
      for _MENU_SUB in "${_SELECTED_APPS[@]}"; do
        ${_MENU_SUB}
      done
      if [[ -z "${_SCRIPT_MESSAGES[@]}" ]]; then
        whiptail --title "Success" --yes-button "Back to List" --no-button "Quit" --yesno "The selected application(s) has been ${1}ed." 7 53 || exit
      else
        # Print message
        whiptail --scrolltext --title "Script Messages" --yes-button "OK" --no-button "Quit" --yesno "$(printf "%b\n" "${_SCRIPT_MESSAGES[@]}")" 10 75 || exit
      fi
    fi
    _menu_sub "${_preserved_command}"
  else
    cmd_menu
  fi
}

# Whiptail: Package's description settings
#
# Return:
#   Whiptail radiolist
#
_menu_show_desc() {
  if [[ "$_SHOW_DESC" == 1 ]]; then
    _SHOW_DESC_ENABLE="ON"; _SHOW_DESC_DISABLE="OFF"
  else
    _SHOW_DESC_ENABLE="OFF"; _SHOW_DESC_DISABLE="ON"
  fi
  _SHOW_DESC_OPTIONS=$( whiptail --notags --title "Show Packages' Description" --radiolist "\nDisplay information of applications in selection menus. Enabling slows down script execution!" 10 65 2 \
      "1" "Enable" $_SHOW_DESC_ENABLE \
      "0" "Disable (default)" $_SHOW_DESC_DISABLE \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    _SHOW_DESC=$_SHOW_DESC_OPTIONS
  fi
  cmd_menu
}

# System updating
#
_system_update() {
  # Refresh repository...
  printf "Please wait... "
  if hash flatpak 2>/dev/null; then
    flatpak update
  fi
  sudo apt update -qq

  # Upgrading packages if necessary
  if [[ $(LANG=C apt-get upgrade -s | grep -P '^\d+ upgraded'| cut -d" " -f1) != 0 ]]; then
    sudo apt upgrade -y
  fi

  # Install translations if language support is not installed completely
  if [[ -n "$(check-language-support)" ]]; then
    sudo apt install -y $(check-language-support)
  fi
}

# System cleaning
#
_system_cleanup() {
  # Remove leftover config files
  if [[ -z "$(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)" ]]; then
    printf "There aren't leftover config files.\n"
  else
    printf "Remove leftover config files:\n"
    sudo dpkg --purge $(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)
  fi

  # Flatpak unused applications
  if hash flatpak 2>/dev/null; then
    printf "Unused Flatpak package(s)... "
    flatpak uninstall -y --unused
  fi

  # Clean packages cache
  sudo apt clean

  # Remove orphaned packages
  if [[ $(LANG=C apt-get autoremove -s | grep -P '^\d+ upgraded'| cut -d" " -f6) -ne 0 ]]; then
    sudo apt autoremove -y -qq
  fi
}

# Configure System
#
_system_settings() {

  # UFW enable
  sudo ufw default deny incoming
  sudo ufw default allow outgoing
  sudo ufw allow ssh comment 'Connection to ssh' && printf "  ⇢  Rule: Connection to ssh\n"
  if [[ $(sudo ufw status 2>/dev/null | grep Status: | cut -d ' ' -f 2) != "active" ]]; then
    sudo ufw --force enable
  fi
  sudo ufw reload

  # Hidde things...
  [[ $(cat ~/.hidden 2> /dev/null | grep -q "snap"; echo $?) != 0 ]] && echo "snap" >> ~/.hidden

  # Gsettings
  gsettings set org.gnome.desktop.interface clock-format 24h
  gsettings set org.gnome.Terminal.Legacy.Settings theme-variant 'dark'
  # gsettings set org.gnome.shell enabled-extensions "['apps-menu@gnome-shell-extensions.gcampax.github.com', 'ubuntu-dock@ubuntu.com', 'ubuntu-appindicators@ubuntu.com', 'alternate-tab@gnome-shell-extensions.gcampax.github.com', 'auto-move-windows@gnome-shell-extensions.gcampax.github.com', 'launch-new-instance@gnome-shell-extensions.gcampax.github.com', 'places-menu@gnome-shell-extensions.gcampax.github.com', 'drive-menu@gnome-shell-extensions.gcampax.github.com', 'screenshot-window-sizer@gnome-shell-extensions.gcampax.github.com']"
  gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true
  gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'LEFT'
  gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true
  gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed true
  gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'
  gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots-color '#dddddd'
  gsettings set org.gnome.nautilus.preferences default-folder-viewer 'list-view'
  gsettings set org.gnome.desktop.interface clock-show-date true
  gsettings set org.gnome.desktop.interface gtk-theme 'Adwaita'

  # Disabling crash dialogs
  if [[ $(cat '/etc/default/apport' | grep -q 'enabled=0'; echo $?) != 0 ]]; then
    sudo sed -i "s/enabled=1/enabled=0/g" /etc/default/apport
  fi

  # Return to menu
  # whiptail --title "Success" --msgbox "The desktop has been configured." 7 40
  # cmd_menu
}

# Display error information (\`dmesg\`)
#
_system_error() {
  if [[ $(dmesg --level=err,crit,emerg -H --time-format iso | grep -m1 :; echo $?) == 1 ]]; then
    printf "There isn't error message.\n"
  else
    dmesg --level=err,crit,emerg -H --time-format iso
  fi
}

# Display system information
#
_system_info() {
  hostnamectl
  timedatectl
  sudo ufw status
  sudo lshw -short -c system -c memory -c processor
}

# Creating a desktop file - Helper function for cmd_install()...
#
# Args:
#   $1 (required): Package name
#
# Return:
#   Desktop file, that will be located in $HOME/.local/share/applications/ folder.
#
_create_desktop_entry() {
  local _NAME=$(whiptail --inputbox "\nWhat is your package name?" 8 75 "${1}" --title "Create a desktop file: ~/.local/share/applications/${1}" 3>&1 1>&2 2>&3)
  local _DESCRIPTION=$(whiptail --inputbox "\nAdd a description for the package" 8 75 "${1} - App" --title "Create a desktop file: /.local/share/applications/${1}" 3>&1 1>&2 2>&3)
  cat > /tmp/${1}.desktop <<DESKTOPFILE
[Desktop Entry]
Name=${_NAME}
Comment=${_DESCRIPTION}
Exec=${1}
TryExec=${1}
Type=Application
DESKTOPFILE
  desktop-file-install --dir=$HOME/.local/share/applications /tmp/${1}.desktop
  whiptail --title "Desktop Entry: ${1}" --textbox $HOME/.local/share/applications/${1}.desktop 16 60
}


# VirtualBox - Helper function for cmd_install()...
#
_install_virtualbox() {
  if hash virtualbox 2>/dev/null; then
    _VER_CUR_VBOX="$(vboxmanage -v | cut -d 'r' -f1)"
    _VER_LAT_VBOX="$(curl -s https://download.virtualbox.org/virtualbox/LATEST.TXT)"
    _VER_LAT_VBOX_REPO="$(dpkg-query -W --showformat='${Version}' virtualbox* | cut -d- -f1)"
    if _check_version ${_VER_LAT_VBOX_REPO} ${_VER_CUR_VBOX}; then
      printf "A new version of the VirtualBox (%s) is available!\n" "${_VER_LAT_VBOX}"
      read -p "Do you want me to update? [y/n] " REPLY
    else
      printf "VirtualBox (%s) is installed and up-to-date.\n" "${_VER_CUR_VBOX}"
      if _check_version ${_VER_LAT_VBOX} ${_VER_LAT_VBOX_REPO}; then
        printf "$(tput setaf 3)...but a newer (%s) deb package is already available.$(tput sgr0)\n" "${_VER_LAT_VBOX}"
      fi
    fi
  else
    _REPLY=y
  fi
  # Install VirtualBox
  if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
    if [ ! -f "/etc/apt/sources.list.d/virtualbox.list" ]; then
      _UBUNTU_CODENAME="$(cat /etc/*-release 2>/dev/null | grep UBUNTU_CODENAME | cut -d= -f2)"
      sudo bash -c "cat > /etc/apt/sources.list.d/virtualbox.list" <<VBOXLIST
    deb [arch=amd64] https://download.virtualbox.org/virtualbox/debian ${_UBUNTU_CODENAME} contrib
VBOXLIST
      wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
      wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -
      sudo apt-get update
    fi
    sudo apt -y install virtualbox-6.0
  fi
  # VirtualBox Extension Pack (syncing with current version of VirtualBox)
  _VER_USED_VBOXREV="$(vboxmanage list extpacks | tr -s ' ' | grep Revision | awk '{ print $2 }')"
  _VER_CUR_VBOXREV="$(vboxmanage -v | cut -d 'r' -f2)"
  if [ "${_VER_USED_VBOXREV}" != "${_VER_CUR_VBOXREV}" ]; then
    _VBOB_LICENSE_KEY="56be48f923303c8cababb0bb4c478284b688ed23f16d775d729b89a2e8e5f9eb"
    if [ ! -f "/tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack" ]; then
      wget https://download.virtualbox.org/virtualbox/${_VER_CUR_VBOX}/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack -O /tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack
    fi
    sudo VBoxManage extpack install /tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack --replace --accept-license=${_VBOB_LICENSE_KEY}
    sudo VBoxManage extpack cleanup
    printf "VirtualBox Extension Pack (...r%s) has been installed and updated!\n" "${_VER_CUR_VBOXREV}"
  fi
}

# Vagrant - Helper function for cmd_install()...
#
_install_vagrant() {
  _VER_LAT_VAGRANT=$(vagrant version | grep Latest | cut -d' ' -f3)
  if hash vagrant 2>/dev/null; then
    _VER_CUR_VAGRANT=$(vagrant version | grep Installed | cut -d' ' -f3)
    if _check_version ${_VER_LAT_VAGRANT} ${_VER_CUR_VAGRANT}; then
      printf "A new version of the Vagrant (%s) is available!\n" "${_VER_LAT_VAGRANT}"
      read -p "Do you want me to update? [y/n] " REPLY
      _INSTALL=true
    else
      printf "Vagrant (%s) is installed and up-to-date.\n" "${_VER_CUR_VAGRANT}"
    fi
  else
    _INSTALL=true
  fi
  # Install Vagrant
  if ${_INSTALL:-false}; then
    if [ ! -f "/tmp/vagrant.deb" ]; then
      wget https://releases.hashicorp.com/vagrant/${_VER_LAT_VAGRANT}/vagrant_${_VER_LAT_VAGRANT}_x86_64.deb -O /tmp/vagrant.deb
    fi
    sudo dpkg -i /tmp/vagrant.deb
    sudo apt install -fy
  fi
}

# Anki - Helper function for cmd_install()...
#
_install_anki() {
  if [[ $(_check_package_exists "anki") == 0 ]]; then
    _VER_ANKI="2.1.11"
    wget https://apps.ankiweb.net/downloads/current/anki-${_VER_ANKI}-linux-amd64.tar.bz2 -O /tmp/anki.tar.bz2
    tar -xj /tmp/anki.tar.bz2 -C /tmp
    cd /tmp/${_VER_ANKI}
    sudo make install
    cd ..
    # Change default `$HOME/.local/share/Anki2/` folder to custom directory
    sudo sed -i 's|^Exec=.*|Exec=sh -c "anki %f -b $HOME/Anki"|g' /usr/local/share/applications/anki.desktop
  fi
}

# Settings after installation
#
_setting_app() {
  if _contains "mysql" "${_APP_SETTING[@]}"; then
    echo "Run mysql setting..."
  fi
  if _contains "atom" "${_APP_SETTING[@]}"; then
    if [ -! -d "${HOME}/.atom/packages/atom-beautify/" ]; then
      pip3 install beautysh
      apm install atom-beautify
    fi
  fi
}

# Installing software applications with different package formats and methods
#
# Usage:
#   cmd_install --app [packagename] --flat [LOCATION/REMOTE] --snap --pack
#
# Return:
#   Installed package with the given method(s).
#
_HELP[install]=$(cat << HELPINTSALL
The \`install\` command installs a package on the system.
Use --app to set the package name when installing.

  Usage:
    $(basename "${0}") install [options] [<arguments]

  Options:
    -a, --app          Name of package
    -p, --pack         Install software from main repository (apt-get)
    -r, --repo         Add repository to sources list
    -k, --key          Download and add key to package installation
    -d, --deb          Download the package as .deb and install using dpkg
    -s, --snap         Install software using Snap package management
    -f, --flat         Install software using Flatpak package management
        --ppa          Install packages from PPAs
        --appimg       Download AppImage
        --set          Settings after installation
        --fun          Install package with custom function
    -h, --help         Display this help
        --debug        Run debug mode
HELPINTSALL
)

cmd_install() {

  _PACK="" # (required) --app option argument
  _APP_SETTING=() # Settings into array variable

  # Options parser
  _OPTS_INSTALL=$(getopt --options ha:pr:k:d:s::f: --long help,app:,pack,repo:,key:,deb:,snap::,flat:,appimg:,ppa:,set:,fun:,classic --name "$(basename "${0}") ${_CMD}" -- "${@}")
  if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
  eval set -- "${_OPTS_INSTALL}"

  while true; do
    case "${1}" in
      -h|--help) cmd_help ${_CMD}; shift ;;
      --debug) set -x ; _DEBUG=true ; shift ;;
      -a|--app) _PACK=${2}
        shift 2 ;;
      -p|--pack)
        sudo apt install -y ${_PACK}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift ;;
      --d|-deb) _DEB_ARGS=${2}
        if [[ $(_check_package_exists "${_PACK}") != 0 ]]; then
          wget ${_DEB_ARGS} -O /tmp/${_PACK}.deb
          if [[ "${?}" -ne 0 ]]; then
            _SCRIPT_MESSAGES+=("There is something wrong with the downloading of \`${_DEB_ARGS}\`.")
          fi
          sudo dpkg -i /tmp/${_PACK}.deb
          sudo apt install -fy
        fi
        shift 2 ;;
      -r|--repo) _REPO_ARGS=${2}
        if [[ ! -f "/etc/apt/sources.list.d/${_PACK}.list" ]]; then
          echo "${_REPO_ARGS}" | sudo tee /etc/apt/sources.list.d/${_PACK}.list
        fi
        shift 2 ;;
      -k|--key) _KEY_ARGS=${2}
        wget -q "${_KEY_ARGS}" -O- | sudo apt-key add -
        sudo apt update -qq
        cmd_install --pack ${_PACK}
        shift 2 ;;
      -s|--snap) _SNAP_ARGS=${2}
        if [[ $(_check_package_exists "snapd") != 0 ]]; then
          sudo apt install -y snapd
        fi
        snap install ${_PACK} ${_SNAP_ARGS}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift 2 ;;
      --classic)
        # This option (classic) is only a snap hack, so it can be use as an install argument...
        shift ;;
      -f|--flat) _FLAT_ARGS=${2}
        if [[ $(_check_package_exists "flatpak") != 0 ]]; then
          sudo apt install -y flatpak gnome-software-plugin-flatpak
          flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
          _SCRIPT_MESSAGES+=("After first installation of Flatpak is recommend\nrestart your system to complete setup.")
        fi
        flatpak install --assumeyes flathub ${_FLAT_ARGS}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift 2 ;;
      --appimg) _APPIMG_ARGS=${2}
        # AppImag location
        if [[ ! -d "${HOME}/.local/bin/" ]]; then
          mkdir -p ${HOME}/.local/bin/
        fi
        # Make location executable
        if [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
          if [[ $(cat ~/.bashrc | grep "export PATH" &> /dev/null; echo $?) -eq 0 ]]; then
            sed -i "s|^export PATH=.*|export PATH=${PATH}:${HOME}/.local/bin|" ~/.bashrc
          else
            echo "export PATH=${PATH}:${HOME}/.local/bin" >> ~/.bashrc
          fi
          # Current session && Next ones
          export PATH=${PATH}:${HOME}/.local/bin && source ~/.bashrc && printf "Updated source...\n"
        fi
        # Get AppImage
        if [[ $(_check_package_exists "${_PACK}") != 0 ]]; then
          wget "${_APPIMG_ARGS}" -O ${HOME}/.local/bin/${_PACK}
          if [[ "${?}" -ne 0 ]]; then
            rm ${HOME}/.local/bin/"${1}"
            _SCRIPT_MESSAGES+=("There is something wrong with the downloading of \`${_DEB_ARGS}\`.")
          fi
          chmod a+x ${HOME}/.local/bin/${_PACK}
        fi
        # AppImage Launcher
        if [ ! -f "$HOME/.local/share/applications/${_PACK}.desktop" ]; then
          _create_desktop_entry "${_PACK}"
        fi
        shift 2 ;;
      --ppa) _PPA_ARGS=${2}
        shift 2 ;;
      --fun) _FUN_ARGS=${2}
        ${_FUN_ARGS}
        shift 2 ;;
      --set) _SET_ARGS=${2}
        _APP_SETTING+=( "${_SET_ARGS}" )
        shift 2 ;;
      --) shift ; break ;;
      *) _error "internal option error '${1}'" ;;
    esac
  done

  if [[ "${_OPTS_INSTALL}" == " --" ]]; then
    cmd_help "${_CMD}"
  fi

  # Run settings
  _setting_app
}


# COMMAND: Removing software applications
#
_HELP[remove]=$(cat << HELPREMOVE
The \`remove\` command removes the all format of a package from the system.

  Usage:
    $(basename "${0}") remove --app <packagename>

  Options:
    -a, --app <name>    Name of package
    -h, --help          Display this help
        --debug         Run debug mode
HELPREMOVE
)

cmd_remove() {

  _PACK="" # (required) --app option argument

  # Options parser
  _OPTS_UINSTALL=$(getopt --options ha: --long help,debug,app: --name "$(basename "${0}") ${_CMD}" -- "${@}")
  if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
  eval set -- "${_OPTS_UINSTALL}"

  while true ; do
    case "${1}" in
      -h|--help) cmd_help ${_CMD}; shift ;;
      --debug) set -x ; _DEBUG=true ; shift ;;
      -a|--app) _PACK=${2} ; shift 2 ;;
      --) shift ; break ;;
      *) _error "internal option error '${1}'" ;;
    esac
  done

  if [[ -z "${_PACK}" ]]; then
    _error "missing required option -- 'app'"
  else
    if [[ $(_check_package_exists "${_PACK}") == 0 ]]; then
      if [[ "$(_check_package_exists --print-status "${_PACK}")" == *"pack"* ]]; then
        sudo apt-get remove -y "${_PACK}"
      fi
      if [[ "$(_check_package_exists --print-status "${_PACK}")" == *"snap"* ]]; then
        sudo snap remove "${_PACK}"
      fi
      if [[ "$(_check_package_exists --print-status "${_PACK}")" == *"flat"* ]]; then
        _FLATPAK_PACK=$(flatpak list --app | grep "${_PACK}" | cut -d/ -f1)
        sudo flatpak uninstall --assumeyes "${_FLATPAK_PACK}"
      fi
      if [[ "$(_check_package_exists --print-status "${_PACK}")" == *"complied"* ]]; then
        _SCRIPT_MESSAGES+=("☹ Sorry, '${_PACK}' package can remove manually only.")
      fi
    fi
    # Run system cleanup
    _system_cleanup
  fi
}

# COMMAND: Vagrant
#
_HELP[vagrant]=$(cat << HELPVAGRANTFILE
The \`vagrant\` command creates a Vagrantfile in the <PATH> directory.

  Usage:
    $(basename "${0}") vagrant --path <path> [options]

  Options:
    -i, --ip <ipadress> IP adress for private network [default: 192.168.33.10]
    -p, --path <path>   Place the \`Vagrantfile\` (required)
    -h, --help          Display this help
        --debug         Run debug mode
HELPVAGRANTFILE
)

cmd_vagrant() {

  ! _check_desktop && printf "%b\n" "${_CHAS_MESSAGE}" && exit 1

  local _PATH=""
  local _IP="192.168.33.10"

  # Options parser
  _OPTS_VAGRANT=$(getopt --options hp:i --long help,debug,path:,ip --name "$(basename "${0}") ${_CMD}" -- "${@}")
  if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
  eval set -- "${_OPTS_VAGRANT}"

  while true ; do
    case "${1}" in
      -h|--help) cmd_help ${_CMD}; shift ;;
      --debug) set -x ; _DEBUG=true ; shift ;;
      -p|--path) _VAGRANT=true ; _PATH=${2} ; shift 2 ;;
      -i|--ip) _IP="${2}" ; shift 2 ;;
      --) shift ; break ;;
      *) _error "internal option error '${1}'" ;;
    esac
  done

  if ! "${_VAGRANT:-false}"; then
    _error "missing required option -- 'path'"
  else
    [ ! -d "${_PATH}" ] && printf  "No such directory - '%s'\n" "${_PATH}"
    if [ ! -f "${_PATH}/Vagrantfile" ]; then
      # Create a Vagrantfile to the $PATH directory
      cat > ${_PATH}/Vagrantfile <<VRAGANTFILE
# -*- mode: ruby -*-
# vi: set ft=ruby :
# Overwrite host locale in vagrant ssh session
ENV["LC_ALL"] = "en_US.UTF-8"
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/bionic64"
  config.vm.network "private_network", ip: "${_IP}"
  config.vm.hostname = "VPS"
  config.vm.synced_folder "www/", "/var/www", create: true
  config.vm.provider "virtualbox" do |vb|
    vb.memory = "4096"
    vb.name = "VPS-$RANDOM"
    # Do not use NAT mode instead to use the PCnet or Paravirtualized network
    vb.default_nic_type = "Am79C973"
    vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
    vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]
    # Disable the cloudimg-console.log
    # vb.customize [ "modifyvm", :id, "--uartmode1", "disconnected" ]
  end
end
VRAGANTFILE

      printf "A \`Vagrantfile\` has been placed in '%s' directory.\nYou are now ready to \`vagrant up\` your first virtual environment!\n  ⇢  Private network IP: $(tput setaf 3)%s$(tput sgr0)\n" "${_PATH}" "${_IP}"
    else
      printf "A Vagrantfile already exists in '%s'.\n" "${_PATH}"
    fi
  fi
}

# COMMAND: Nginx
#
_check_desktop && _NGINX_NOTE="  Note:\n    It's not recommended to run on desktop environment,\n    that's why this command is not allowed default.\n"

_HELP[nginx]=$(cat << HELPNGINX
The \`nginx\` command  builds the mainline version of Nginx from source.

${_NGINX_NOTE}
  Usage:
    $(basename "${0}") nginx [options] [<arguments>...]

  Options:
    -i, --install       Install and rebuid Nginx for updating
    -c, --config        Update all the config files and reload server
    -b, --block         Add or update a server block
                        argument <domainname>
    -r, --root          Set server root path
                        [default argument: '/var/www/<doman>/html']
    -s, --ssl           Enable https server
                        [default: disable]
        --sub           Set subdomain alias
                        argument <sugdomainalias>
        --type=<args>   Set type for server block
                        block types: <basic>|<php>|<fastcgi>|<odoo>|<nodejs>
                        [default: basic]
    -d, --disable       Disable server block
                        argument: <domainname>
    -h, --help          Display this help
        --debug         Run debug mode
        --force         Enable running on desktop
HELPNGINX
)

# Note:
#   * Clear https in Chrome: chrome://net-internals/#hsts

cmd_nginx() {

  # Options parser
  local _DOMAIN=""
  local _SUB=""
  local _DISABLE_SITE=""
  local _ROOT_PATH="/var/www"
  _OPTS_NGINX=$(getopt --options hficb:r:s,d: --long help,debug,install,config,block:,root:,ssl,type::,sub:,disable:,force --name "$(basename "${0}") ${_CMD}" -- "${@}")
  if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
  eval set -- "${_OPTS_NGINX}"

  while true ; do
    case "${1}" in
      -h|--help) cmd_help ${_CMD} ; shift ;;
      --debug) set -x ; _DEBUG=true ; shift ;;
      -i|--install) _INSTALL=true ; shift ;;
      -c|--config) _CONFIG=true ; shift ;;
      -b|--block) _DOMAIN="${2}" ; shift 2 ;;
      -r|--root) _CUSTOM_ROOT=true ; _ROOT_PATH="${2}" ; shift 2 ;;
      --sub) _SUB="${2}" ; shift 2 ;;
      --type)
        case "${2}" in
          "basic"|"php"|"fastcgi"|"odoo"|"nodejs") _BLOCK_TYPE=${2} ; shift 2 ;;
          *) _error "unsupported type of server block -- '${2}'" ; shift ;;
        esac ;;
      -s|--ssl) _SSL=true ; shift ;;
      -d|--disable) _DISABLE_SITE="${2}" ; shift 2 ;;
      --force) _FORCE=true ; shift ;;
      --) shift ; break ;;
      *) _error "internal option error '${1}'" ;;
    esac
  done

  if ! "${_FORCE:-false}"; then
    _check_desktop && printf "%b\n" "${_CHAS_MESSAGE}" && exit 1
  fi

  local _VER_LAT_NGINX="$(echo $(curl -s http://nginx.org/en/CHANGES) | grep -m1 'Changes with nginx' | cut -d' ' -f4)"
  local _VER_PCRE="8.43"
  local _VER_ZLIB="1.2.11"
  local _VER_OPENSSL="1.1.1b"
  local _VER_GEOIP2="3.2"
  local _IP="$(hostname -I | awk '{print $1}')"
  [[ "${_FORCE:-false}" ]] && local _IP="$(hostname -i)"
  [ -d /home/vagrant ] && local _IP="$(hostname -I | awk '{print $2}')"
  local _USER_WEB="www-data"
  local _THIS_HOST=$(hostname)

  if hash nginx 2>/dev/null; then
    _VER_CUR_NGINX="$(echo $(nginx -v 2>&1) | cut -d/ -f 2)"
    # Check version
    if _check_version $_VER_LAT_NGINX $_VER_CUR_NGINX; then
      printf "A newer version (%s) is available than the current version (%s)!\n" "${_VER_LAT_NGINX}" "${_VER_CUR_NGINX}"
      read -p "Do you want me to update? [y/n] " REPLY
    else
      printf " ✔  Nginx (%s) is up to date!\n" "${_VER_CUR_NGINX}"
      if "${_INSTALL:-false}"; then
        read -p "Do you want me to rebuild? [y/n] " REPLY
      fi
    fi
  else
    read -p "Do you want to install the Nginx server? [y/n] " REPLY
    [[ "${REPLY:-}" =~ ^[Nn]$ ]] && exit 0
  fi

  ##
  # Installing Nginx
  ##
  if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then

    _VER_NGINX=${_VER_LAT_NGINX}

    # Make a backup
    if [ -d "/etc/nginx" ]; then
      _BACKUP_TIME="$(LC_ALL=C date +%Y%m%d_%H%M%S)"
      sudo mv /etc/nginx /etc/nginx_backup_${_BACKUP_TIME}
    fi

    # Downloading Nginx and its dependencies
    if [ ! -d "/tmp/nginx-${_VER_NGINX}" ]; then
      wget -qO- https://nginx.org/download/nginx-${_VER_NGINX}.tar.gz -O /tmp/nginx-${_VER_NGINX}.tar.gz
      tar -xvzf /tmp/nginx-${_VER_NGINX}.tar.gz -C /tmp
    fi
    if [ ! -d "/tmp/openssl-${_VER_OPENSSL}" ]; then
      wget -qO- https://www.openssl.org/source/openssl-${_VER_OPENSSL}.tar.gz -O /tmp/openssl-${_VER_OPENSSL}.tar.gz
      tar -xvzf /tmp/openssl-${_VER_OPENSSL}.tar.gz -C /tmp
    fi
    if [ ! -d "/tmp/pcre-${_VER_PCRE}" ]; then
      wget -qO- https://ftp.pcre.org/pub/pcre/pcre-${_VER_PCRE}.tar.gz -O /tmp/pcre-${_VER_PCRE}.tar.gz
      tar -xvzf /tmp/pcre-${_VER_PCRE}.tar.gz -C /tmp
    fi
    if [ ! -d "/tmp/zlib-${_VER_ZLIB}" ]; then
      wget -qO- https://zlib.net/zlib-${_VER_ZLIB}.tar.gz -O /tmp/zlib-${_VER_ZLIB}.tar.gz
      tar -xvzf /tmp/zlib-${_VER_ZLIB}.tar.gz -C /tmp
    fi
    if [ ! -d "/tmp/ngx_http_geoip2_module-${_VER_GEOIP2}" ]; then
      wget -qO- https://github.com/leev/ngx_http_geoip2_module/archive/${_VER_GEOIP2}.tar.gz -O /tmp/${_VER_GEOIP2}.tar.gz
      tar -xvzf /tmp/${_VER_GEOIP2}.tar.gz -C /tmp
    fi

    # Add nginx user group if they do not already exist
    sudo id -g nginx &>/dev/null || sudo addgroup --system nginx
    sudo id -u nginx &>/dev/null || ( sudo adduser --disabled-password --system --home /var/cache/nginx --shell /sbin/nologin --group nginx || _error "adding new nginx user and group" )

    # Nginx's some directory is not created by default
    sudo mkdir -p /var/cache/nginx/{client_temp,proxy_temp,fastcgi_temp,uwsgi_temp,scgi_temp}

    # Install required softwares
    sudo apt install -y build-essential

    # Update or install GeoIP2 database
    if hash geoipupdate 2>/dev/null; then
      if [ ! -f "/usr/share/GeoIP/.geoipupdate.lock" ]; then
        (sudo geoipupdate) &
        _spinner $! "Updating GeoIP database \`/usr/share/GeoIP\`.\nThis is going to take a few minutes."
      fi
    else
      sudo add-apt-repository ppa:maxmind/ppa -y
      sudo apt update -qq
      sudo apt install -y geoipupdate libmaxminddb-dev
      sudo geoipupdate
    fi

    # You can verify compiler support for __uint128_t with the following
    # https://wiki.openssl.org/index.php/Compilation_and_Installation
    if gcc -dM -E - </dev/null | grep __SIZEOF_INT128__  ; 	then _ENABLE_EC="enable-ec_nistp_64_gcc_128"; else _ENABLE_EC=""; fi

    cd /tmp/nginx-${_VER_NGINX}
    ./configure \
      --prefix=/etc/nginx \
      --with-pcre=../pcre-${_VER_PCRE} \
      --with-zlib=../zlib-${_VER_ZLIB} \
      --with-openssl=../openssl-${_VER_OPENSSL} \
      --add-dynamic-module=../ngx_http_geoip2_module-${_VER_GEOIP2} \
      --with-openssl-opt="no-weak-ssl-ciphers no-ssl3 enable-tls1_3 no-shared ${_ENABLE_EC} -DOPENSSL_NO_HEARTBEATS -fstack-protector-strong" \
      --with-cc-opt='-g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2' \
      --with-ld-opt='-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now -fPIC' \
      --sbin-path=/usr/sbin/nginx \
      --conf-path=/etc/nginx/nginx.conf \
      --pid-path=/var/run/nginx.pid \
      --lock-path=/var/run/nginx.lock \
      --modules-path=/usr/lib/nginx/modules \
      --error-log-path=/var/log/nginx/error.log \
      --http-log-path=/var/log/nginx/access.log \
      --http-client-body-temp-path=/var/cache/nginx/client_temp \
      --http-proxy-temp-path=/var/cache/nginx/proxy_temp \
      --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \
      --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \
      --http-scgi-temp-path=/var/cache/nginx/scgi_temp \
      --with-http_ssl_module \
      --user=nginx \
      --group=nginx \
      --with-file-aio \
      --with-pcre-jit \
      --with-stream \
      --with-stream_ssl_module \
      --with-threads \
      --with-http_auth_request_module \
      --with-http_gunzip_module \
      --with-http_gzip_static_module \
      --with-http_mp4_module \
      --with-http_flv_module \
      --with-http_realip_module \
      --with-http_secure_link_module \
      --with-http_slice_module \
      --with-http_ssl_module \
      --with-http_v2_module \
      --with-http_stub_status_module \
      --with-http_sub_module \
      --without-http_empty_gif_module \
      --without-http_split_clients_module \
      --without-http_ssi_module \
      --without-mail_imap_module \
      --without-mail_pop3_module \
      --without-mail_smtp_module

    (sudo make --no-print-directory >/dev/null 2>/dev/null) &
    _spinner $! "Make Nginx..."
    sudo make install > /dev/null
    sudo make clean > /dev/null

    sudo ln -s /usr/lib/nginx/modules /etc/nginx/modules

    # Allow UFW for Nginx
    sudo bash -c "cat > /etc/ufw/applications.d/nginx" <<NGINXUFW
[Nginx HTTP]
title=Web Server (Nginx, HTTP)
description=Small, but very powerful and efficient web server
ports=80/tcp

[Nginx HTTPS]
title=Web Server (Nginx, HTTPS)
description=Small, but very powerful and efficient web server
ports=443/tcp

[Nginx Full]
title=Web Server (Nginx, HTTP + HTTPS)
description=Small, but very powerful and efficient web server
ports=80,443/tcp
NGINXUFW
    sudo ufw allow 'Nginx Full' comment 'Web Server (HTTP + HTTPS)' > /dev/null

    # Restoring config files
    if [ -d "/etc/nginx_backup_${_BACKUP_TIME:-}" ]; then
      # Keep the compiled 'fresh install' files in /etc/nginx/nginx_default
      if [ -d "/etc/nginx_default" ]; then
        sudo rm -rf /etc/nginx_default
      fi
      sudo mv /etc/nginx /etc/nginx_default
      sudo mv /etc/nginx_backup_${_BACKUP_TIME:-} /etc/nginx
      sudo cp /etc/nginx_default/*.default /etc/nginx/
    fi
    printf "✔ Nginx is downloaded and installed.\n"
    # Continue configurations...
    _CONFIG=true
  fi # ...end of Nginx server's downloading, updating or installing

  ##
  # Configure Nginx
  ##
  if "${_CONFIG:-false}"; then

    # Create server directories if doesn't exists
    sudo mkdir -p \
      /etc/{nginx/conf.d,nginx/snippets,letsencrypt} \
      /var/www/{default_server/html,_letsencrypt,_cache}

    # Nginx default config file
    sudo bash -c "cat > /etc/nginx/nginx.conf" <<NGINXCONFIG
##
# Modules
##
load_module modules/ngx_http_geoip2_module.so;

##
# Nginx Configurations
##
user ${_USER_WEB};
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    ##
    # Index directive one time
    ##
    index index.php index.htm index.html;

    ##
    # GeoIP Database
    ##
    geoip2 /usr/share/GeoIP/GeoLite2-Country.mmdb {
        \$geoip2_data_country_code country iso_code;
    }

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # Log format (.csv compatible)
    ##
    log_format main '--- "\$time_iso8601"; "\$remote_addr"; "\$status"; '
    '"\$request"; "\$http_user_agent"; "\$http_referer"; '
    '"\$http_x_forwarded_for"; "\$remote_user"; "\$body_bytes_sent"; '
    '"\$ssl_protocol"; "\$ssl_cipher"; ';
    access_log /var/log/nginx/access.log  main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    client_max_body_size 100M;
    client_body_buffer_size 1m;

    ##
    # Secure config
    ##
    server_tokens off;
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options SAMEORIGIN always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header Content-Security-Policy "default-src 'self' https://*; connect-src 'self' https://* wss://*; font-src 'self' https://* blob: data:; frame-src 'self' https://* blob: data:; img-src 'self' https://* blob: data:; media-src 'self' https://* blob: data:; object-src 'self' https://* blob: data:; script-src 'self' https://* 'unsafe-inline' 'unsafe-eval'; style-src 'self' https://* 'unsafe-inline';";
    add_header "X-UA-Compatible" "IE=Edge";

    ##
    # Cache-Control - Expiration
    ##
    map \$sent_http_content_type \$expires {
        default                    off;
        text/html                  epoch;
        text/css                   14d;
        application/javascript     max;
        ~image/                    max;
        ~video/                    max;
        ~audio/                    max;
    }

    ##
    # Enable GZIP
    ##
    gzip on;
    gzip_comp_level 5;
    gzip_min_length 256;
    gzip_vary on;
    gzip_proxied any;
    gzip_types text/plain text/css application/javascript image/*;
    gzip_disable "MSIE [1-6]\.(?!.*SV1)";

    ##
    # FastCGI cache config
    ##
    fastcgi_cache_key "\$scheme\$request_method\$host\$request_uri";
    fastcgi_cache_use_stale error timeout invalid_header http_500;
    fastcgi_ignore_headers Cache-Control Expires Set-Cookie;

    ##
    # Odoo server
    ##
    upstream odoo {
        server 127.0.0.1:8069;
    }
    upstream odoochat {
        server 127.0.0.1:8072;
    }

    ##
    # NodeJS server
    ##

    ##
    # Including serever block configurations
    ##
    include /etc/nginx/conf.d/*.conf;
}
NGINXCONFIG

    # Nginx (global) restrictions config
    sudo bash -c "cat > /etc/nginx/snippets/restrictions.conf" <<NGINXRESTRICTION
##
# Global restrictions (If custom error pages defined, than 'logging off' here is irrelevant)
##
location ~ /\. {
    deny all;
}

location = /favicon.ico {
  	log_not_found off;
  	access_log off;
    error_log off;
}

location = /robots.txt {
    allow all;
    log_not_found off;
    access_log off;
}

##
# WordPress specific config
##
location = /wp-config.php { deny all; }
location = /wp-config-sample.php { return 404; }
location = /readme.html { deny all; }
# location = /xmlrpc.php { return 404; }
location ~* /(license.txt|nginx.conf) { deny all; }
location ~* /(?:uploads|files)/.*\.php\$ { deny all; }
location ~* ^/(wp-content)/(.*?)\.(zip|gz|tar|bzip2|7z)\$ { deny all; }
# WordPress EDD plugin
rewrite ^/wp-content/uploads/edd/(.*)\.zip\$ / permanent;
rewrite ^/media/edd/(.*)\.zip\$ / permanent;

##
# PhpMyadmin - Block attempts to access phpMyAdmin (If you actually use it, don't include this rule!)
##
# location ~* .([pP]hp[mM]y[aA]dmin) { return 404; }

##
# Disallow cgi scripts
##
# location ~* \.(pl|cgi|py|sh|lua)\$ { return 444; }
# Make sure files with the following extensions do not get loaded by nginx because nginx would display the source code...
# location ~* \.(engine|inc|info|install|make|module|profile|test|po|sh|.*sql|theme|tpl(\.php)?|xtmpl)\$|^(\..*|Entries.*|Repository|Root|Tag|Template)\$|\.php_ { return 444; }

##
# Maintenance - Allow full access to certain IP
##
# if (\$remote_addr != "192.168.33.1") { return 503; }
NGINXRESTRICTION

    # Nginx ssl-stapling config
    sudo bash -c  "cat > /etc/nginx/snippets/ssl-stapling.conf" <<NGINXSSL
##
# SSL Stapling
##
ssl_stapling on;
ssl_stapling_verify on;
resolver 8.8.8.8 8.8.4.4 valid=60s;
resolver_timeout 30s;
NGINXSSL

    # Nginx phpmyadmin config
    sudo bash -c "cat > /etc/nginx/snippets/phpmyadmin.conf" <<NGINXPHPADMIN
##
# PhpMyAdmin
##
location /phpmyadmin {

    root /usr/share/;
    location ~ ^/phpmyadmin/(doc|sql|setup|libraries|templates)/ {
        return 404;
    }

    location ~ ^/phpmyadmin/(.+\.php)\$ {
        try_files \$uri =404;
        fastcgi_index index.php;
        fastcgi_pass unix:/run/php/php${_VER_PHP:-7.2}-fpm.sock;
        include /etc/nginx/fastcgi.conf;
    }

    location ~* ^/phpmyadmin/(.+\.(jpg|jpeg|gif|css|png|js|ico|html|xml|txt))\$ {
        root /usr/share/;
    }

}
NGINXPHPADMIN

    # Logrotate configuration
    sudo bash -c "cat > /etc/logrotate.d/nginx" <<-NGINXLOGROTATE
/var/log/nginx/*.log {
    su root syslog
    create 0640 www-data adm
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    sharedscripts
    postrotate
        if [ -f /var/run/nginx.pid ]; then
                kill -USR1 \`cat /var/run/nginx.pid\`
        fi
    endscript
}

# Turn to force the update
# sudo logrotate -f -v /etc/logrotate.d/nginx
NGINXLOGROTATE

    # Enable logrotate compression
    sudo sed -i "s/#compress/compress/g" /etc/logrotate.conf
    # Turn to force the update
    sudo logrotate -f -v /etc/logrotate.d/nginx &> /dev/null

    # Add Block: Default server block
    #
    if [ -d "/home/vagrant" ]; then _return="# "; else _return=""; fi

    if "${_SSL:-false}"; then
      sudo bash -c "cat > /etc/nginx/conf.d/default.conf" <<HTTPSDEFAULTBLOCK
server {
    listen 80 default_server;
    server_name _;
    root /var/www/default_server/html;

    ##
    # Let's Encrypt Settings (it is necessary for the certificate to be renewable by certbot)
    ##
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

    ##
    # Log
    ##
    access_log /var/log/nginx/default-access.log main;
    error_log /var/log/nginx/default-error.log;

    ##
    # Restrictions
    ##
    include /etc/nginx/snippets/restrictions.conf;

    ${_return}return 444;

}

server {
    listen 443 ssl http2 default_server;
    server_name _;
    root /var/www/default_server/html;

    ##
    # Let's Encrypt Settings
    ##
    location ^~ /.well-known/acme-challenge/ {
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

    ##
    # SSL Enable
    ##
    ssl_prefer_server_ciphers on;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";
    # ssl_cipher "TLS-CHACHA20-POLY1305-SHA256:TLS-AES-256-GCM-SHA384"; # More secure but less compatible
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets off; # Requires nginx >= 1.5.9
    ssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    ssl_certificate /etc/letsencrypt/live/${_THIS_HOST}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${_THIS_HOST}/privkey.pem;
    ${_SSL_STAPLING:-}

    ##
    # Log
    ##
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    ##
    # Restrictions
    ##
    include /etc/nginx/snippets/restrictions.conf;

    ${_return}return 444;
}
HTTPSDEFAULTBLOCK
    else
      sudo bash -c "cat > /etc/nginx/conf.d/default.conf" <<HTTPDEFAULTBLOCK
server {
    listen 80 default_server;
    server_name _;
    root /var/www/default_server/html;

    location ^~ /.well-known/acme-challenge/ {
        allow all;
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

    ##
    # Log
    ##
    access_log /var/log/nginx/default-access.log main;
    error_log /var/log/nginx/default-error.log;

    ##
    # Restrictions
    ##
    include /etc/nginx/snippets/restrictions.conf;

    ${_return}return 444;
}
HTTPDEFAULTBLOCK
    fi

    # Index file
    sudo bash -c "cat > /var/www/default_server/html/index.html" <<INDEXHTML
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Server</title>
  <meta name="description" content="Server">
  <style>.center{text-align: center!important;}</style>
  </head>
  <body>
    <p class="center">${_IP}</p>
  </body>
</html>
INDEXHTML

    # Add blank favicon.ico
    if [ ! -f "/var/www/default_server/html/favicon.ico" ]; then
      sudo touch /var/www/default_server/html/favicon.ico
    fi

    # Set ownership and permissions
    sudo chown -R ${_USER_WEB}:${_USER_WEB} /var/www/default_server/html
    sudo chown -R root:root /var/log/nginx

    # Nginx init script
    if [ -f "/lib/systemd/system/nginx.service" ]; then
      _RELOAD_DEMON=true
    fi
    sudo bash -c "cat > /lib/systemd/system/nginx.service" <<NGINXSERVICE
[Unit]
Description=Nginx - HTTP and reverse proxy server
After=network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/var/run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf
ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf
ExecReload=/bin/kill -s HUP \$MAINPID
ExecStop=/bin/kill -s TERM \$MAINPID

[Install]
WantedBy=multi-user.target

NGINXSERVICE
    # Useful links:
    #   https://www.nginx.com/resources/wiki/start/topics/examples/systemd/
    #   http://nginx.org/en/docs/control.html

    # [Unit]
    # Description=Nginx - HTTP and reverse proxy server
    # After=network.target nss-lookup.target
    #
    # [Service]
    # Type=forking
    # PIDFile=/run/nginx.pid
    # ExecStartPre=/usr/sbin/nginx -t -q -g 'daemon on; master_process on;'
    # ExecStart=/usr/sbin/nginx -g 'daemon on; master_process on;'
    # # See https://github.com/angristan/nginx-autoinstall/issues/67
    # ExecStartPost=/bin/sleep 0.1
    # ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload
    # ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid
    # TimeoutStopSec=5
    # KillMode=mixed
    #
    # [Install]
    # WantedBy=multi-user.target

    # Reload deamon because of the modify (update)
    if ${_RELOAD_DEMON:-}; then
      sudo systemctl daemon-reload > /dev/null
    fi

    # Nginx service
    if [[ $(systemctl status nginx.service | grep Active: | cut -d ' ' -f 5) != "active" ]]; then
      # Enable Nginx to start on boot and start Nginx immediately
      sudo systemctl enable nginx.service || _error "install and enable Nginx -- 'sysremctl'"
      sudo systemctl start nginx.service || _error "install and starting Nginx -- 'sysremctl'"
      # sudo ln -sf /lib/systemd/system/nginx.service /etc/systemd/system/multi-user.target.wants/
      printf "✔  Starting Nginx is OK\n"
      [ -d /home/vagrant ] && printf " ⇢  Default server: $(tput setaf 3)http://%s$(tput sgr0)\n" "${_IP}"
    else
      # Check if Nginx will automatically initiate after a reboot:
      if [[ $(systemctl is-enabled nginx.service) != "enabled" ]]; then
        sudo systemctl enable nginx.service || _error "configure and enable Nginx -- 'sysremctl'"
      fi
      sudo nginx -s reload || _error "configure and reloading Nginx"
      printf " ✔  Nginx Reloading is OK\n"
      [ -d /home/vagrant ] && printf " ⇢  Default server: $(tput setaf 3)http://%s$(tput sgr0)\n" "${_IP}"
    fi
  fi # ..end of server configure

  ##
  # Creating a server block
  ###
  if [[ -n "${_DOMAIN:-}" ]]; then

    # If subdomain
    if [[ -n "${_SUB}" ]]; then
      _SUB="${_SUB}."
    fi

    # Set server root
    if "${_CUSTOM_ROOT:-false}"; then
      _ROOT_PATH=/var/www${_ROOT_PATH}
    else
      _ROOT_PATH=${_ROOT_PATH}/${_SUB}${_DOMAIN}/html
    fi

    # Only in case of testing on localhost
    if [[ "${_DOMAIN}" == "${_THIS_HOST}" ]]; then
      _ROOT_PATH=/var/www/default_server/html
      _ssl_certificate
      $(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "$0") nginx --config --ssl
      exit
    fi

    # Confirmation
    printf "\nCreating / Updating a Server Block for %s\n" "${_SUB}${_DOMAIN}"
    printf "  - domain:        %s\n" "${_SUB}${_DOMAIN}"
    printf "  - root path:     %s\n" "${_ROOT_PATH}"
    printf "  - ssl:           %s\n" "${_SSL:-false}"
    printf "  - type:          %s\n" "${_BLOCK_TYPE:-basic}"
    read -p "Are you sure? [y/n] " REPLY

    if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then

      # Set FQDN
      _FQDN="${_IP} ${_THIS_HOST}.${_DOMAIN} ${_THIS_HOST}"
      grep "${_FQDN}" /etc/hosts &>/dev/null || printf "%s\n" "${_FQDN}" | sudo tee -a /etc/hosts > /dev/null

      # Create root path
      sudo mkdir -p ${_ROOT_PATH}

      # Add index file
      if [ ! -f "${_ROOT_PATH}/index.html" ]; then
        sudo bash -c "cat > "${_ROOT_PATH}"/index.html" <<INDEXHTML
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Welcome to ${_DOMAIN}</title>
        <meta name="description" content="Welcome to ${_DOMAIN}">
        <style>.center{text-align: center!important;}</style>
    </head>
    <body>
        <p class="center">Welcome to ${_DOMAIN}</p>
    </body>
</html>
INDEXHTML
      fi

      # Add blank favicon.ico
      if [ ! -f "${_ROOT_PATH}/favicon.ico" ]; then
        sudo touch ${_ROOT_PATH}/favicon.ico
      fi

      ##
      # START SERVER BLOCK [default: redirect www to non-www]
      ##
      sudo bash -c "cat > /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<HTTPSERVERBLOCK
server {
    listen 80;
    server_name www.${_SUB}${_DOMAIN};
    return 301 http://${_SUB}${_DOMAIN}\$request_uri;
}

server {
    listen 80;
    server_name ${_SUB}${_DOMAIN};
    root ${_ROOT_PATH};

    ##
    # Let's Encrypt Settings (it is necessary for the certificate to be renewable by certbot)
    ##
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

HTTPSERVERBLOCK

      if "${_SSL:-false}"; then

        # Add Block: Restrictions ...and close a valid config file befor create certificate
        #
        sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<RESTRICTIONSBLOCK
    ##
    # Restrictions
    ##
    include /etc/nginx/snippets/restrictions.conf;
}
RESTRICTIONSBLOCK

        # Reloading
        sudo nginx -s reload || _error "reloading Nginx -- 'befor creating SSL certificates'"

        # Create a certificate
        _ssl_certificate

        # "Re-open" the block: Create new block for https
        #
        sudo bash -c "cat > /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<HTTPSSERVERBLOCK
server {
    listen 80;
    server_name ${_SUB}${_DOMAIN} www.${_SUB}${_DOMAIN};

    ##
    # Let's Encrypt Settings (it is necessary for the certificate to be renewable by certbot)
    ##
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

    location / {
        return 301 https://${_SUB}${_DOMAIN}\$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name www.${_SUB}${_DOMAIN};
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    ssl_certificate /etc/letsencrypt/live/${_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${_DOMAIN}/privkey.pem;
    return 301 https://${_SUB}${_DOMAIN}\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ${_SUB}${_DOMAIN};
    root ${_ROOT_PATH};

    ##
    # Let's Encrypt Settings
    ##
    location ^~ /.well-known/acme-challenge/ {
        default_type "text/plain";
        root /var/www/_letsencrypt;
    }

    ##
    # SSL Enable
    ##
    ssl_prefer_server_ciphers on;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";
    # ssl_cipher "TLS-CHACHA20-POLY1305-SHA256:TLS-AES-256-GCM-SHA384"; # More secure but less compatible
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets off; # Requires nginx >= 1.5.9
    ssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    ssl_certificate /etc/letsencrypt/live/${_DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${_DOMAIN}/privkey.pem;
    ${_SSL_STAPLING:-}

HTTPSSERVERBLOCK
      fi # ...end if $_SSL true

      # Add Block: Log and chache config
      #
      sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<LOGBLOCK
    ##
    # Log
    ##
    access_log /var/log/nginx/${_SUB}${_DOMAIN}-access.log main;
    error_log /var/log/nginx/${_SUB}${_DOMAIN}-error.log;

    ##
    # Cache
    ##
    expires \$expires;

LOGBLOCK

      # Add Block: Odoo
      #
      if [[ "${_BLOCK_TYPE:-basic}" == "odoo" ]]; then
        sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<ODOOBLOCK
    ##
    # Odoo
    ##
    proxy_read_timeout 720s;
    proxy_connect_timeout 720s;
    proxy_send_timeout 720s;
    proxy_set_header X-Forwarded-Host \$host;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;
    proxy_set_header X-Real-IP \$remote_addr;

    ##
    # Redirect longpoll requests to odoo longpolling port
    ##
    location /longpolling {
        proxy_pass http://odoochat;
    }

    ##
    # Redirect requests to odoo backend server
    ##
    location / {
      proxy_redirect off;
      proxy_pass http://odoo;
    }

ODOOBLOCK
      else # ...end if Odoo

        # Add Block: 404 fall back
        #
        sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<EOF
    ##
    # Fall back to displaying a 404
    ##
    location / {
        try_files \$uri \$uri/ =404;
    }

EOF

        # Add Block: PHP
        #
        if hash php 2>/dev/null; then

          # Add to theblock: Php FastCGI
          #
          if [[ "${_BLOCK_TYPE:-basic}" == "fastcgi" ]]; then
            sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<FASTCGIBLOCK
    ##
    # Fascgi Cache
    ##
    set \$skip_cache 0;

    # POST requests and urls with a query string should always go to PHP
    if (\$request_method = POST) {
      set \$skip_cache 1;
    }
    if (\$query_string != "") {
        set \$skip_cache 1;
    }

    # Don't cache uris containing the following segments
    if (\$request_uri ~* "/wp-admin/|/xmlrpc.php|wp-.*.php|/feed/|index.php|sitemap(_index)?.xml|/php-test/|/phpmyadmin/|/checkout/|/account/|/privacy.*/") {
        set \$skip_cache 1;
    }

    # Don't use the cache for logged in users or recent commenters
    if (\$http_cookie ~* "edd_items_in_cart|comment_author|wordpress_[a-f0-9]+|wp-postpass|wordpress_no_cache|wordpress_logged_in") {
        set \$skip_cache 1;
    }

    ##
    # PHP
    ##
    location ~ [^/]\.php(/|\$) {
        # The name of the cache key-zone to use
        fastcgi_cache fastcgicache_${_DOMAIN};
        # What to cache: 'code 200' responses, for half an hour
        fastcgi_cache_valid 200 30m;
        # What to cache: only GET and HEAD requests (POST)
        fastcgi_cache_methods GET HEAD;
        # Allow us to see if the cache was HIT, MISS, or BYPASSED inside
        # a browser's Inspector panel
        add_header X-Fastcgi-Cache \$upstream_cache_status;
        # Dont pull from the cache if true
        fastcgi_cache_bypass \$skip_cache;
        # Dont save to the cache if true
        fastcgi_no_cache \$skip_cache;
        proxy_cache_revalidate on;
        proxy_cache_min_uses 3;
        proxy_cache_use_stale error timeout updating http_500 http_502
        http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;
        try_files \$uri =404;
        fastcgi_index index.php;
        fastcgi_pass unix:/run/php/php${_VER_PHP:-7.2}-fpm.sock;
        include /etc/nginx/fastcgi.conf;
    }

    # Check the page load response headers. Values of x-fastcgi-cache:
    # - HIT    - The page is being returned from the NGINX FastCGI cache
    # - MISS   - The page wasn't cached and was returned by PHP-FPM
    #            (refreshing the page should return either a HIT or a BYPASS)
    # - BYPASS - The page has been cached but the cached version wasn't served.
    #            This occurs when it is a page that we have specified
    #            to bypass the cache,
    #            such as an admin page, or when a user is logged in.

FASTCGIBLOCK
          else # ... end php fastcgi

            # Add Block: Basic Php
            #
            if [[ "${_BLOCK_TYPE:-basic}" == "php" ]]; then
              sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<BASICPHPBLOCK
    ##
    # Php
    ##
    location ~ \.php\$ {
        try_files \$uri =404;
        fastcgi_index index.php;
        fastcgi_pass unix:/run/php/php${_VER_PHP:-7.2}-fpm.sock;
        include /etc/nginx/fastcgi.conf;
    }

BASICPHPBLOCK
            fi # ...end basic php
          fi # ...end if not php fastcgi (basic php)

          # Add Block: PhpMyAdmin
          #
          sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<PHPMYADMINBLOCK
    include /etc/nginx/snippets/phpmyadmin.conf;

PHPMYADMINBLOCK
        fi # ...end php
      fi # ...end if not Odoo

      # Add Block and finishing, closing: Restrictions
      #
      sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<EOF
    ##
    # Restrictions
    ##
    include /etc/nginx/snippets/restrictions.conf;
}
EOF
      ##
      # END SERVER BLOCK
      ##

      # Fastcgi Cache Path
      if hash php 2>/dev/null; then
        if [[ "${_BLOCK_TYPE:-basic}" == "fastcgi" ]]; then
          sudo bash -c "cat >> /etc/nginx/conf.d/${_SUB}${_DOMAIN}.conf" <<FASTCGICACHEPATH
    ##
    # Fastcgi Cache Path
    ##
    # fastcgi_cache_path /var/run/nginx-cache-fastcgi levels=1:2 keys_zone=fastcgicache_${_SUB}${_DOMAIN}:10m max_size=500m inactive=60m use_temp_path=off;
    fastcgi_cache_path /var/www/_cache/${_DOMAIN} levels=1:2 keys_zone=fastcgicache_${_SUB}${_DOMAIN}:10m max_size=500m inactive=60m use_temp_path=off;
FASTCGICACHEPATH
        fi
      fi


      # Reload Nginx
      sudo nginx -s reload || _error "reloading Nginx -- 'after adding a server block'"
      printf "\n ✔  Server block for %s is ready!\n" "${_SUB}${_DOMAIN}"

      # Print info message(s)
      #
      if "${_SSL:-false}"; then
        _SCHEME="https"
      else
        _SCHEME="http"
      fi

      if [ -d "/home/vagrant" ]; then
        # Info if MailCatcher running (Set your favourite app to deliver to local smtp://127.0.0.1:1025 instead of your default SMTP server.)
        if hash mailcatcher 2>/dev/null; then
          printf "  - check out http://%s:1080 to see the mail(s)\n" "${_IP}"
        fi
      fi

      [[ "${_DOMAIN}" == "${_THIS_HOST}" ]] && _DOMAIN=${_IP}
      printf "\nOpen up your web browser and navigate to following url:\n ⇢  $(tput setaf 3)%s://%s$(tput sgr0)\n" "${_SCHEME}" "${_SUB}${_DOMAIN}"


    else # ... end if confirmation is YES
      printf "Exiting...\n"
      exit
    fi
  fi # ...end of creating server block

  # Disable a server block
  #
  if [[ -n "${_DISABLE_SITE}" ]]; then
    if [ -f "/etc/nginx/conf.d/${_DISABLE_SITE}.conf" ]; then
      sudo mv /etc/nginx/conf.d/${_DISABLE_SITE}.conf /etc/nginx/conf.d/${_DISABLE_SITE}.disabled
      printf " ✔  Site is disabled: %s\n" "${_DISABLE_SITE}"
    else
      if [ -f "/etc/nginx/conf.d/${_DISABLE_SITE}.disabled" ]; then
        printf " ✔  Site is already disabled: %s\n" "${_DISABLE_SITE}"
      else
        _error "there isn't any configuration for this domain -- '%s'\n" "${_DISABLE_SITE}"
      fi
    fi
  fi
}

# SSL certificate - Helper function for cmd_nginx()...
#
_ssl_certificate() {

  # Generating DH parameters
  if [ ! -f "/etc/letsencrypt/ssl-dhparams.pem" ]; then
    sudo mkdir -p /etc/letsencrypt
    (sudo openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 4096 > /dev/null 2>&1) &
    _spinner $! "Generating DH parameters. Only need to be generated once if there is not exists!\nThis is going to take a few (5-10) minutes."
  fi

  # Self-signed certificate
  if [ -d "/home/vagrant" ]; then
    if [ ! -f "/etc/letsencrypt/live/${_DOMAIN}/fullchain.pem" ]; then
      sudo cp -rf /etc/ssl/openssl.cnf /tmp/openssl.${_DOMAIN}.cnf
      sudo sed -i "1i SAN=\"email:info@${_DOMAIN}\"" /tmp/openssl.${_DOMAIN}.cnf
      # Create a certificate for default host
      #
      # Example Usage:
      #   --block VPS --ssl     Default host available at https://192.168.33.10
      #                         after you imported the VPS-fullchain crt. file(s) to the Chrome web browser
      #
      if [[ "${_DOMAIN}" == "${_THIS_HOST}" ]]; then
        sudo sed -i "s/^# Extensions for a typical CA/subjectAltName=IP:${_IP}/g" /tmp/openssl.${_DOMAIN}.cnf
      else
        sudo sed -i "s/^# Extensions for a typical CA/subjectAltName=DNS:${_DOMAIN}, DNS:www.${_DOMAIN}, DNS:*.${_DOMAIN}/g" /tmp/openssl.${_DOMAIN}.cnf
      fi
      sudo mkdir -p /etc/letsencrypt/live/${_DOMAIN}
      sudo openssl req \
        -x509 -new -sha256 -days 365 -nodes -newkey rsa:2048 \
        -subj "/C=US/ST=New York/L=New York/O=123 SSL - Local Tester/OU=IT/CN=${_DOMAIN}" \
        -out /etc/letsencrypt/live/${_DOMAIN}/fullchain.pem \
        -keyout /etc/letsencrypt/live/${_DOMAIN}/privkey.pem \
        -config /tmp/openssl.${_DOMAIN}.cnf > /dev/null 2>&1 || _error "creating self-signed certificate -- '${_DOMAIN}'"
    fi

    # Import to web browsers (vagrant-triggers or manual import)
    cat "/etc/letsencrypt/live/${_DOMAIN}/fullchain.pem" | sudo tee /var/www/_letsencrypt/${_DOMAIN}-local-fullchain.crt > /dev/null

    #  Including ssl stapling snippet --> Ssl stapling not supported on localhost
    # _SSL_STAPLING="include /etc/nginx/snippets/ssl-stapling.conf;"

    # Print message(s)
    if [[ -n ${_SUB:-} ]]; then
      _HOST_CONTENT="${_IP} ${_DOMAIN} www.${_DOMAIN} ${_SUB}${_DOMAIN}"
    else
      _HOST_CONTENT="${_IP} ${_DOMAIN} www.${_DOMAIN}"
    fi
    printf "\nDon't forget:\n"
    printf "  - add this entry to your \`/etc/hosts\` file (on host):\n    $(tput setaf 3)%s$(tput sgr0)\n" "${_HOST_CONTENT}"

    if "${_SSL:-false}"; then
      printf "  - import the \`/var/www/_letsencrypt/%s-local-fullchain.crt\` file\n    to the Chrome web browser\n" "${_DOMAIN}"
    fi

  else

    # Let's Encrypt certificate
    if ! hash certbot 2>/dev/null; then
      sudo apt -y install software-properties-common
      sudo add-apt-repository ppa:certbot/certbot -y
      sudo apt update && sudo apt -y install certbot python-certbot-nginx
    fi
    if [ ! -d "/var/www/_letsencrypt/.well-known/acme-challenge" ]; then
      sudo mkdir -p /var/www/_letsencrypt/.well-known/acme-challenge
    fi

    # Run certbot (Test: certbot --dry-run)
    if ! sudo certbot certificates | grep --quiet www.${_DOMAIN}; then
      sudo certbot certonly --webroot --agree-tos --no-eff-email --email ${_CERT_EMAIL} -w /var/www/_letsencrypt -d ${_DOMAIN} -d www.${_DOMAIN} || _error "creating Let’s Encrypt certificate -- '${_DOMAIN}'"
    fi

    # Expand certbot (for example new sub_DOMAIN) - Let’s Encrypt doesn’t offer wildcard (at the current time [2018-07-26])
    if ${_SUB:-}; then
      if ! certbot certificates | grep --quiet ${_SUB}${_DOMAIN}; then
        sudo certbot certonly --expand --agree-tos --no-eff-email -w /var/www/_letsencrypt -d ${_DOMAIN} -d www.${_DOMAIN} -d ${_SUB}${_DOMAIN} || _error "creating Let’s Encrypt certificate -- '${_SUB}${_DOMAIN}'"
      fi
    fi

    # Including ssl stapling snippet
    _SSL_STAPLING="include /etc/nginx/snippets/ssl-stapling.conf;"

    # Message
    printf "Creating Let’s Encrypt certificate for https://%s is done\n" "${_SUB}${_DOMAIN}"
  fi
}

# Call the `_main` function after everything has been defined
#
_main "$@"
