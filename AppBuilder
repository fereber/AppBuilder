#!/bin/bash

_VERSION='1.0.0'

_APP_COMMON=()
_APP_ADVANCED=()
_APP_GAME=()
_APP_CODEC=()
_APP_NON_FAVORITE=()

declare -A _APP_INSTALL

_APP_COMMON+=( nautilus )                        ; _APP_INSTALL[nautilus]="--pack"
_APP_COMMON+=( gedit )                           ; _APP_INSTALL[gedit]="--pack"

_APP_ADVANCED+=( dconf-editor )                  ; _APP_INSTALL[dconf-editor]="--pack"
_APP_ADVANCED+=( gnome-tweak-tool )              ; _APP_INSTALL[gnome-tweak-tool]="--pack"

_APP_NON_FAVORITE+=( ubuntu-web-launchers )      ; _APP_INSTALL[ubuntu-web-launchers]="--pack"
_APP_NON_FAVORITE+=( gnome-characters )          ; _APP_INSTALL[gnome-characters]="--snap" # prefer main source to snap

export NEWT_COLORS="root=,black window=,lightgray title=black, button=lightgray,black actbutton=black,lightgray checkbox=black,lightgray actcheckbox=lightgray,black listbox=black,lightgray actlistbox=lightgray,black sellistbox=black,lightgray actsellistbox=lightgray,gray textbox=black,lightgray acttextbox=lightgray,black border= shadow= entry= label= helpline= roottext= emptyscale= fullscale= disentry= compactbutton= "

_dimension() {
  LINES=""; LINES=$(tput lines); COLUMNS=""; COLUMNS=$(tput cols)
}

# Check if one element value exists in a list or array
#
_contains() {
  local _list=(${*:2})
  for _element in "${_list[@]:-}"; do [[ "${_element}" == "${1}" ]] && return 0; done
  return 1
}

# Version controll
#
_check_version() {
  test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

# Cheking System
#
_check_os_and_distro() {
  # Check OS
  [[ $(uname) != "Linux" ]] && printf "Sorry! This script only suports Linux!\nExiting...\n" && exit 1
  # Check distribution
  if [[ $(which lsb_release &>/dev/null; echo $?) -ne 0 ]]; then
    printf "Sorry! Can't be checked which distribution you are using!\nExiting...\n"
    exit 1
  else
    _DISTRIB_ID=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_ID | cut -d= -f2); _DISTRIB_CODENAME=$(cat /etc/*-release 2>/dev/null | grep DISTRIB_CODENAME | cut -d= -f2); _UBUNTU_CODENAME=$(cat /etc/*-release 2>/dev/null | grep UBUNTU_CODENAME | cut -d= -f2); _DISTRIB_DESCRIPTION=$(lsb_release -ds)
    if ! lsb_release -ds | grep -qE '(Ubuntu|Mint|elementary|Debian)'; then
      if ! (whiptail --title "Warning" --yesno "You are using a distribution that may not be full compatible with this script. Are you sure you want to continue?" 10 50); then
        exit 1
      fi
    fi
  fi
}

# Check system environment
#
_check_desktop() {
  # Check chassis
  if [[ $(hostnamectl | grep Chassis | awk '{print $2}') == "vm" ]]; then
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on desktop environment.\nIt's not recommended to run on server environment."
    return 1
  else
    _CHAS_MESSAGE="This command \`${_CMD}\` helps building apps on server environment.\nIt's not recommended to run on desktop environment."
    return 0
  fi
}

# Check timezone
#
_check_timezone() {
  _CUR_TIMEZONE="$(timedatectl | grep -e 'Time zone' | tr -s " " | cut -d ' ' -f 4)"
  if [[ "${_CUR_TIMEZONE}" == "Etc/UTC" ]] || [[ "${_CUR_TIMEZONE}" == "" ]]; then
    printf "Current timezone on system: %s\n" "${_CUR_TIMEZONE}"
    read -p "Do you want to set a new timezone? [y/n] " REPLY
    if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
      local _TIMEZONE=$(whiptail --inputbox "\nEnter the new time zone (format: Continent/City):" 8 75 --title "Timezone Setting" 3>&1 1>&2 2>&3)
      if [[ $(timedatectl list-timezones | grep "${_TIMEZONE}" &> /dev/null; echo $?) != "0" ]]; then
        _error "invalid timezone --'${_TIMEZONE}'"
      else
        sudo timedatectl set-timezone "${_TIMEZONE}" && whiptail --title "Success" --msgbox "The timezone changed to ${_TIMEZONE}." 7 80
      fi
    fi
  else
    return 0
  fi
}

# Check git config
#
_check_git_config() {
  if hash git 2>/dev/null; then
    if [[ -z "$(git config user.name)" ]] || [[ -z "$(git config user.email)" ]]; then
      printf "Git is installed, but missing your Git identity.\nThis is important because every Git commit uses this information.\n"
      read -p "Do you want to set your user name and email address? [y/n] " REPLY
      if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
        local _USER_GIT=$(whiptail --inputbox "\nEnter the name for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        local _EMAIL_GIT=$(whiptail --inputbox "\nEnter the e-mai adress for Git user:" 8 75 --title "Git Setting" 3>&1 1>&2 2>&3)
        git config --global user.name "${_USER_GIT}"
        git config --global user.email "${_EMAIL_GIT}"
      fi
    fi
  fi
}

# Determine if a package exists
#
_check_package_exists() {
  if [ $# -gt 2 ]; then
    echo "Error: Too many arguments in ${FUNCNAME[0]}() function!"
    exit 1
  elif [ $# -eq 2 ]; then
    if [ "${1}" != "--print-status" ]; then
      echo "Error: Unrecognized option in ${FUNCNAME[0]}() function: \`${1}\`!"
      exit 1
    fi
    local _PACKAGE=${2}
  else
    local _PACKAGE=${1}
  fi
  local _COUNT=0; local _SOURCE=(); local _INSTALL_STATUS="✔" # https://coolsymbol.com/
  if [[ $(dpkg-query -W --showformat='${Status}\n' ${_PACKAGE} 2>/dev/null | grep "install ok installed" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    _SOURCE+=( pack )
  fi
  # Software Source: AppImage
  if [[ $(type -P "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
    let _COUNT+=1
    if [ "$(type -P "${_PACKAGE}")" == "/usr/bin/${_PACKAGE}" ]; then
      if ! _contains "pack" "${_SOURCE[*]}"; then
        _SOURCE+=( pack )
      fi
    fi
    if [ "$(type -P "${_PACKAGE}")" == "$HOME/.local/bin/${_PACKAGE}" ]; then
      _SOURCE+=( appimg )
    fi
    if [ -f "/usr/local/share/${_PACKAGE}/Makefile" ]; then
      _SOURCE+=( complied )
    fi
  fi
  if hash snapd 2>/dev/null; then
    if [[ $(snap list | grep "^${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( snap )
    fi
  fi
  # Software Source: Flat Store
  if hash flatpak 2>/dev/null; then
    if [[ $(flatpak list | grep "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
      let _COUNT+=1
      _SOURCE+=( flat )
    fi
  fi
  if [ "${1}" == "--print-status" ]; then
    if [[ "${_COUNT}" -eq 0 ]]; then
      _INSTALL_STATUS="✖"
      _SOURCE+=( " -- " )
    fi
    # Print status and info of sources
    (IFS="+$IFS"; printf '%s (%s)' "${_INSTALL_STATUS}" "${_SOURCE[*]}")
  else
    if [[ "${_COUNT}" -gt 0 ]]; then
      echo 0
    else
      echo 1
    fi
  fi
}

# Script dependencies
#
_check_dependencies() {
  # Depends packages
  local _DEP_PACK=("whiptail wget curl git"); local _REQ_PACK=""; local _MISSING_PACK="";
  for _MISSING_PACK in ${_DEP_PACK}; do
    [[ $(_check_package_exists "${_MISSING_PACK}") != 0 ]] && _REQ_PACK+=("${_MISSING_PACK}")
  done
  if [ -n "${_REQ_PACK}" ]; then
    printf "This script requires some packages, but the following are not present on your system.\n"
    printf "  * %s\n" "${_REQ_PACK[@]}"
    read -p 'Would you like to install these packages to continue? [Y/n] ' REPLY
    case $REPLY in
      [Yy]* )
        cmd_install --pack "${_REQ_PACK[*]}" ;;
      [Nn]* )
        echo "Exiting..." && exit ;;
      * )
        echo "Sorry, try again." && _check_dependencies ;;
    esac
  fi
}

# Exit with an error and print the specified message
#
_error() {
  printf "\n$(tput bold)$(tput setaf 1) ✖ Error: %s$(tput sgr0)\n\n" "${*}" 1>&2
  exit 1
}

# Get commands and command functions
#
_get_command_functions() {
  local _function_list=($(printf "%s" "$(declare -F)" | sed -e "s/declare -f //g"))
  for _name in "${_function_list[@]}"; do
    if [[ "${_name}" =~ ^cmd_(.*) ]]; then
      _CMD_FUNCTIONS+=("${_name}")
      _CMD_ALLOWED+=($(printf "%s" "${_name}" | sed -e "s/cmd_//g"))
    fi
  done
}

# The primary function for starting the program.
#
_main() {
  # Checking things
  _check_os_and_distro
  _check_dependencies
  _check_timezone
  _check_git_config

  # Load allowed command
  _get_command_functions

  # Default command
  [[ -z "${_CMD:-}" ]] && _CMD=${1:-menu}

  if ( [[ -n "${_CMD}" ]] && _contains "${_CMD}" "${_CMD_ALLOWED[*]}"); then
    # If the command is defined, run its function...
    cmd_"${_CMD}" "${@:2}"
  else # If the command is not defined, run this...

    # Options parser
    _OPTS=$(getopt --options h,u,c,i,e,s,v --long help,debug,update,clean,info,error,setting,version --name "$(basename "${0}")" -- "${@}")
    if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
    eval set -- "${_OPTS}"

    while true ; do
      case "${1}" in
        -h|--help)     cmd_help ${_CMD} ; shift ;;
        --debug)   set -x ; _DEBUG=true ; shift ;;
        -u|--update)  _system_update    ; shift ;;
        -c|--clean)   _system_cleanup   ; shift ;;
        -i|--info)    _system_info      ; shift ;;
        -e|--error)   _system_error     ; shift ;;
        -s|--setting) _system_settings  ; shift ;;
        -v|--version)
          printf "%s\n" "${_VERSION}"
          shift ;;
        --) shift ; break ;;
        *) _error "internal option error '${1}'"
      esac
    done
  fi
}

# COMMAND: Help
#
# Usage (optional):
#   ```
#   _HELP[command]=$(cat << HELPSOMETHING
#     Usage: ...
#   HELPSOMETHING
#   )
#
#   cmd_command() {
#     echo -n
#   }
#   ```
# Declare command in array without `cmd_` prefix and use in name of function with `cmd_` prefix
#
declare -A _HELP[help]=$(cat << HELPCMD
The menu command displays the help information for '$(basename "${0}")' or
a specified command.

Usage:
  $(basename "${0}") -h | --help
  $(basename "${0}") help <command>

HELPCMD
)

cmd_help() {
  if ( [[ $# -gt 0 ]] && [[ ! "${1}" =~ ^- ]] ); then
    # Help to specific command
    if _contains "${1}" "${_CMD_ALLOWED[*]}"; then
      if _contains "${1}" "${!_HELP[*]}"; then
        printf "%b\n\n" "${_HELP[${1}]}"
      else
        printf "No additional information for '%s'\n" "${1}"
      fi
    else
      printf "Sorry, '%s' is not an allowed command!\n\nAllowed command(s):\n" "${1}"
      printf " %s\n" "${_CMD_ALLOWED[@]}"
    fi
  else
    cat << HELPDESKTOP
The $(basename "$0") is a post install script to help building and setting your system.

  Usage:
    Run '$(basename "${0}")' without options and arguments in interactive mode
    $(basename "${0}") [commands] [options] [<arguments>...]

  Options:
    -u, --update        Update system
    -c, --clean         Cleanup system
    -s, --setting       Configure system
    -i, --info          Display system information
    -e, --error         Display error information (\`dmesg\`)
    -v, --version       Print script version number
    -h, --help          Display this help
        --debug         Run debug mode

  Commands:
    $(printf " %s" "${_CMD_ALLOWED[@]}")

For more information about a command, run '$(basename "${0}") help <command>'
HELPDESKTOP
  fi
  exit
}

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

# COMMAND: Whiptail Main Menu
#
# Return:
#   Whiptail menu dialog box
#
_HELP[menu]=$(cat << HELPMENU
The menu command displays an interactive menu.

  Usage: $(basename "${0}") | $(basename "${0}") menu
HELPMENU
)

cmd_menu(){
  _dimension
  _MENU_MAIN=$(whiptail --title "Main Menu" --menu "\n   What would you like to do? Choose an option..." --cancel-button "Quit" --notags $LINES $COLUMNS $(( $LINES - 10 )) \
      "cmd_menu" "System:" \
      "_system_update" "  Update" \
      "_system_cleanup" "  Cleaning" \
      "_system_info" "  Print Info" \
      "_system_error" "  Print Error" \
      "cmd_menu" "" \
      "cmd_menu" "Installing Applications:" \
      "_menu_sub install _APP_COMMON 'Commonly Used Application' 'Install'" "  Commonly Used ▸" \
      "_menu_sub install _APP_ADVANCED 'Installing Advanced Application' 'Install'" "  Advanced ▸" \
      "_menu_sub install _APP_GAME 'Installing Games' 'Install'" "  Games ▸" \
      "_menu_sub install _APP_CODEC 'Installing Codecs' 'Install'" "  Codecs ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Removing Applications:" \
      "_menu_sub remove _APP_COMMON 'Removing Commonly Used Application' 'Uninstall'" "  Commonly Used ▸" \
      "_menu_sub remove _APP_ADVANCED 'Removing Advanced Application' 'Uninstall'" "  Advanced ▸" \
      "_menu_sub remove _APP_GAME 'Removing Games' 'Uninstall'" "  Games ▸" \
      "_menu_sub remove _APP_CODEC 'Removing Codecs' 'Uninstall'" "  Codecs ▸" \
      "_menu_sub remove _APP_NON_FAVORITE 'Removing Non-favorite Apps' 'Uninstall'" "  Non-favorite Apps ▸" \
      "cmd_menu" "" \
      "cmd_menu" "Settings:" \
      "_menu_show_desc" "  Show App Info" \
      "sudo update-alternatives --config java" "  Config Java" \
      "_system_settings" "  Setting System" \
    3>&1 1>&2 2>&3)
  if [ $? = 0 ]; then
    ${_MENU_MAIN}
  else
    echo "Bye!"
    exit 0
  fi
}

# Helps to build a whiptail checklist for applications
#
# Args:
#   $1 (required): install or remove
#   $2 (required): name of array
#
# Return:
#   Checklist for whiptail submenu into ${_APP_LIST[@]}
#
_menu_checking_list() {
  # Clear the previous list and create a new updated one
  unset _APP_LIST
  # Set list array
  _LIST_ARRAY="$2[@]"
  # Description for package
  _APP_DESC=""
  # Get length of list array for steps in process
  local _STEP=0; local _LIST_LENGTH=$(echo "${!_LIST_ARRAY}" | wc -w)
  # Build the list
  local _PACKAGE=""
  for _PACKAGE in "${!_LIST_ARRAY}"; do
    # Print package's description as well
    if [[ "${_SHOW_DESC}" -eq 1 ]]; then
      if [[ $(apt-cache show "${_PACKAGE}" &> /dev/null; echo $?) == 0 ]]; then
        _APP_DESC=" -$(apt-cache show "${_PACKAGE}" | grep "Description-en" | cut -d: -f 2)" || true
      fi
    fi

    # Set package install status
    _install_status="$(_check_package_exists --print-status "${_PACKAGE}")"

    #Set checked status
    _install_list_check="OFF"
    _remove_list_check="OFF"

    # Set, if app is present on the 'non-favorite list'
    if _contains "${_PACKAGE}" "${_APP_NON_FAVORITE[@]}"; then
      _mark_non_favorite=" ☠  "
      [[ "${_install_status}" != "✖ ( -- )" ]] && _remove_list_check="ON"
    else
      _mark_non_favorite=""
    fi

    # Create whiptail commands
    if [[ "${1}" == "install" ]]; then
      _APP_LIST+=("cmd_install --app ${_PACKAGE} ${_APP_INSTALL[$_PACKAGE]}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_install_list_check})
    elif [[ "${1}" == "remove" ]]; then
      _APP_LIST+=("cmd_remove --app ${_PACKAGE}" "${_install_status} ${_mark_non_favorite}${_PACKAGE}${_APP_DESC}" ${_remove_list_check})
    else
      echo "Error line $LINENO: Menu command is wrong!"; exit
    fi

    # Progress while building the list
    # if [[ "${_SHOW_DESC}" -eq 1 ]]; then
    (( _STEP+=$(( 100 / ${_LIST_LENGTH} +1 )) ))
    echo XXX
    echo $(( $_STEP ))
    echo -e "\nUpdating package information: ${_PACKAGE}"
    echo XXX
    # fi
    # done  > >([[ "${_SHOW_DESC}" -eq 1 ]] && whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
  done > >(whiptail --title "Please wait..." --gauge "\nUpdating package information: " 8 70 0)
}

# Whiptail: Submenu for actions
#
# Usage:
#   _menu_sub install _APP_COMMON 'Installing Commonly Used Application' 'Install'
#
# Args:
#   $1 (required): install or remove
#   $2 (required): Name of array
#   $3 (required): Checklit title
#   $4 (required): Checklist OK button text
#
# Return:
#   Whiptail checklist, where can you start the command for installing or removing
#
_menu_sub() {
  _dimension
  # Keep it for the return
  _preserved_command="${@}"
  eval set -- "${@}"
  # Build a list
  _menu_checking_list "${@}"
  # Checklist
  _CHECK_LIST=$(whiptail --title "${3}" --checklist "\n   Choose one or more apps to ${1}...\n\n   ✔ installed (sources)\n   ✖ not installed\n   ☠ non-favorite\n" \
      --separate-output --cancel-button "Back to Main Menu" --ok-button "${4}" --notags \
      $LINES $COLUMNS $(( $LINES - 14 )) \
      "${_APP_LIST[@]}" \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    i=0
    while read line; do
      _SELECTED_APPS[${i}]=${line}
      i=$(($i+1))
    done <<< "${_CHECK_LIST}"
    if [[ -z "${_SELECTED_APPS[@]}" ]]; then
      whiptail --title "Info" --yes-button "Back" --no-button "Quit" --yesno "Nothing selected, so nothing happened!" 7 45 || exit
    else
      for _MENU_SUB in "${_SELECTED_APPS[@]}"; do
        ${_MENU_SUB}
      done
      if [[ -z "${_SCRIPT_MESSAGES[@]}" ]]; then
        whiptail --title "Success" --yes-button "Back to List" --no-button "Quit" --yesno "The selected application(s) has been ${1}ed." 7 53 || exit
      else
        # Print message
        whiptail --scrolltext --title "Script Messages" --yes-button "OK" --no-button "Quit" --yesno "$(printf "%b\n" "${_SCRIPT_MESSAGES[@]}")" 10 75 || exit
      fi
    fi
    _menu_sub "${_preserved_command}"
  else
    cmd_menu
  fi
}

# Whiptail: Package's description settings
#
# Return:
#   Whiptail radiolist
#
_menu_show_desc() {
  if [[ "$_SHOW_DESC" == 1 ]]; then
    _SHOW_DESC_ENABLE="ON"; _SHOW_DESC_DISABLE="OFF"
  else
    _SHOW_DESC_ENABLE="OFF"; _SHOW_DESC_DISABLE="ON"
  fi
  _SHOW_DESC_OPTIONS=$( whiptail --notags --title "Show Packages' Description" --radiolist "\nDisplay information of applications in selection menus. Enabling slows down script execution!" 10 65 2 \
      "1" "Enable" $_SHOW_DESC_ENABLE \
      "0" "Disable (default)" $_SHOW_DESC_DISABLE \
    3>&1 1>&2 2>&3)
  if [ ${?} = 0 ]; then
    _SHOW_DESC=$_SHOW_DESC_OPTIONS
  fi
  cmd_menu
}

# System updating
#
_system_update() {
  # Refresh repository...
  printf "Please wait... "
  if hash flatpak 2>/dev/null; then
    flatpak update
  fi
  sudo apt update -qq

  # Upgrading packages if necessary
  if [[ $(LANG=C apt-get upgrade -s | grep -P '^\d+ upgraded'| cut -d" " -f1) != 0 ]]; then
    sudo apt upgrade -y
  fi

  # Install translations if language support is not installed completely
  if [[ -n "$(check-language-support)" ]]; then
    sudo apt install -y $(check-language-support)
  fi
}

# System cleaning
#
_system_cleanup() {
  # Remove leftover config files
  if [[ -z "$(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)" ]]; then
    printf "There aren't leftover config files.\n"
  else
    printf "Remove leftover config files:\n"
    sudo dpkg --purge $(COLUMNS= dpkg -l | grep '^rc' | tr -s ' ' | cut -d ' ' -f 2)
  fi

  # Flatpak unused applications
  if hash flatpak 2>/dev/null; then
    printf "Unused Flatpak package(s)... "
    flatpak uninstall -y --unused
  fi

  # Clean packages cache
  sudo apt clean

  # Remove orphaned packages
  if [[ $(LANG=C apt-get autoremove -s | grep -P '^\d+ upgraded'| cut -d" " -f6) -ne 0 ]]; then
    sudo apt autoremove -y -qq
  fi
}

# Configure System
#
_system_settings() {

  # UFW enable
  sudo ufw default deny incoming
  sudo ufw default allow outgoing
  sudo ufw allow ssh comment 'Connection to ssh' && printf "  ⇢  Rule: Connection to ssh\n"
  if [[ $(sudo ufw status 2>/dev/null | grep Status: | cut -d ' ' -f 2) != "active" ]]; then
    sudo ufw --force enable
  fi
  sudo ufw reload

  # Hidde things...
  [[ $(cat ~/.hidden 2> /dev/null | grep -q "snap"; echo $?) != 0 ]] && echo "snap" >> ~/.hidden

  # Gsettings
  gsettings set org.gnome.desktop.interface clock-format 24h
  gsettings set org.gnome.Terminal.Legacy.Settings theme-variant 'dark'
  # gsettings set org.gnome.shell enabled-extensions "['apps-menu@gnome-shell-extensions.gcampax.github.com', 'ubuntu-dock@ubuntu.com', 'ubuntu-appindicators@ubuntu.com', 'alternate-tab@gnome-shell-extensions.gcampax.github.com', 'auto-move-windows@gnome-shell-extensions.gcampax.github.com', 'launch-new-instance@gnome-shell-extensions.gcampax.github.com', 'places-menu@gnome-shell-extensions.gcampax.github.com', 'drive-menu@gnome-shell-extensions.gcampax.github.com', 'screenshot-window-sizer@gnome-shell-extensions.gcampax.github.com']"
  gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true
  gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'LEFT'
  gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true
  gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed true
  gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'
  gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots-color '#dddddd'
  gsettings set org.gnome.nautilus.preferences default-folder-viewer 'list-view'
  gsettings set org.gnome.desktop.interface clock-show-date true
  gsettings set org.gnome.desktop.interface gtk-theme 'Adwaita'

  # Disabling crash dialogs
  if [[ $(cat '/etc/default/apport' | grep -q 'enabled=0'; echo $?) != 0 ]]; then
    sudo sed -i "s/enabled=1/enabled=0/g" /etc/default/apport
  fi

  # Return to menu
  # whiptail --title "Success" --msgbox "The desktop has been configured." 7 40
  # cmd_menu
}

# Display error information (\`dmesg\`)
#
_system_error() {
  if [[ $(dmesg --level=err,crit,emerg -H --time-format iso | grep -m1 :; echo $?) == 1 ]]; then
    printf "There isn't error message.\n"
  else
    dmesg --level=err,crit,emerg -H --time-format iso
  fi
}

# Display system information
#
_system_info() {
  hostnamectl
  timedatectl
  sudo ufw status
  sudo lshw -short -c system -c memory -c processor
}

# Creating a desktop file - Helper function for cmd_install()...
#
# Args:
#   $1 (required): Package name
#
# Return:
#   Desktop file, that will be located in $HOME/.local/share/applications/ folder.
#
_create_desktop_entry() {
  local _NAME=$(whiptail --inputbox "\nWhat is your package name?" 8 75 "${1}" --title "Create a desktop file: ~/.local/share/applications/${1}" 3>&1 1>&2 2>&3)
  local _DESCRIPTION=$(whiptail --inputbox "\nAdd a description for the package" 8 75 "${1} - App" --title "Create a desktop file: /.local/share/applications/${1}" 3>&1 1>&2 2>&3)
  cat > /tmp/${1}.desktop <<DESKTOPFILE
[Desktop Entry]
Name=${_NAME}
Comment=${_DESCRIPTION}
Exec=${1}
TryExec=${1}
Type=Application
DESKTOPFILE
  desktop-file-install --dir=$HOME/.local/share/applications /tmp/${1}.desktop
  whiptail --title "Desktop Entry: ${1}" --textbox $HOME/.local/share/applications/${1}.desktop 16 60
}


# VirtualBox - Helper function for cmd_install()...
#
_install_virtualbox() {
  if hash virtualbox 2>/dev/null; then
    _VER_CUR_VBOX="$(vboxmanage -v | cut -d 'r' -f1)"
    _VER_LAT_VBOX="$(curl -s https://download.virtualbox.org/virtualbox/LATEST.TXT)"
    _VER_LAT_VBOX_REPO="$(dpkg-query -W --showformat='${Version}' virtualbox* | cut -d- -f1)"
    if _check_version ${_VER_LAT_VBOX_REPO} ${_VER_CUR_VBOX}; then
      printf "A new version of the VirtualBox (%s) is available!\n" "${_VER_LAT_VBOX}"
      read -p "Do you want me to update? [y/n] " REPLY
    else
      printf "VirtualBox (%s) is installed and up-to-date.\n" "${_VER_CUR_VBOX}"
      if _check_version ${_VER_LAT_VBOX} ${_VER_LAT_VBOX_REPO}; then
        printf "$(tput setaf 3)...but a newer (%s) deb package is already available.$(tput sgr0)\n" "${_VER_LAT_VBOX}"
      fi
    fi
  else
    _REPLY=y
  fi
  # Install VirtualBox
  if [[ "${REPLY:-}" =~ ^[Yy]$ ]]; then
    if [ ! -f "/etc/apt/sources.list.d/virtualbox.list" ]; then
      _UBUNTU_CODENAME="$(cat /etc/*-release 2>/dev/null | grep UBUNTU_CODENAME | cut -d= -f2)"
      sudo bash -c "cat > /etc/apt/sources.list.d/virtualbox.list" <<VBOXLIST
    deb [arch=amd64] https://download.virtualbox.org/virtualbox/debian ${_UBUNTU_CODENAME} contrib
VBOXLIST
      wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
      wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -
      sudo apt-get update
    fi
    sudo apt -y install virtualbox-6.0
  fi
  # VirtualBox Extension Pack (syncing with current version of VirtualBox)
  _VER_USED_VBOXREV="$(vboxmanage list extpacks | tr -s ' ' | grep Revision | awk '{ print $2 }')"
  _VER_CUR_VBOXREV="$(vboxmanage -v | cut -d 'r' -f2)"
  if [ "${_VER_USED_VBOXREV}" != "${_VER_CUR_VBOXREV}" ]; then
    _VBOB_LICENSE_KEY="56be48f923303c8cababb0bb4c478284b688ed23f16d775d729b89a2e8e5f9eb"
    if [ ! -f "/tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack" ]; then
      wget https://download.virtualbox.org/virtualbox/${_VER_CUR_VBOX}/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack -O /tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack
    fi
    sudo VBoxManage extpack install /tmp/Oracle_VM_VirtualBox_Extension_Pack-${_VER_CUR_VBOX}.vbox-extpack --replace --accept-license=${_VBOB_LICENSE_KEY}
    sudo VBoxManage extpack cleanup
    printf "VirtualBox Extension Pack (...r%s) has been installed and updated!\n" "${_VER_CUR_VBOXREV}"
  fi
}

# Vagrant - Helper function for cmd_install()...
#
_install_vagrant() {
  _VER_LAT_VAGRANT=$(vagrant version | grep Latest | cut -d' ' -f3)
  if hash vagrant 2>/dev/null; then
    _VER_CUR_VAGRANT=$(vagrant version | grep Installed | cut -d' ' -f3)
    if _check_version ${_VER_LAT_VAGRANT} ${_VER_CUR_VAGRANT}; then
      printf "A new version of the Vagrant (%s) is available!\n" "${_VER_LAT_VAGRANT}"
      read -p "Do you want me to update? [y/n] " REPLY
      _INSTALL=true
    else
      printf "Vagrant (%s) is installed and up-to-date.\n" "${_VER_CUR_VAGRANT}"
    fi
  else
    _INSTALL=true
  fi
  # Install Vagrant
  if ${_INSTALL:-false}; then
    if [ ! -f "/tmp/vagrant.deb" ]; then
      wget https://releases.hashicorp.com/vagrant/${_VER_LAT_VAGRANT}/vagrant_${_VER_LAT_VAGRANT}_x86_64.deb -O /tmp/vagrant.deb
    fi
    sudo dpkg -i /tmp/vagrant.deb
    sudo apt install -fy
  fi
}

# Anki - Helper function for cmd_install()...
#
_install_anki() {
  if [[ $(_check_package_exists "anki") == 0 ]]; then
    _VER_ANKI="2.1.11"
    wget https://apps.ankiweb.net/downloads/current/anki-${_VER_ANKI}-linux-amd64.tar.bz2 -O /tmp/anki.tar.bz2
    tar -xj /tmp/anki.tar.bz2 -C /tmp
    cd /tmp/${_VER_ANKI}
    sudo make install
    cd ..
    # Change default `$HOME/.local/share/Anki2/` folder to custom directory
    sudo sed -i 's|^Exec=.*|Exec=sh -c "anki %f -b $HOME/Anki"|g' /usr/local/share/applications/anki.desktop
  fi
}

# Settings after installation
#
_setting_app() {
  if _contains "mysql" "${_APP_SETTING[@]}"; then
    echo "Run mysql setting..."
  fi
  if _contains "atom" "${_APP_SETTING[@]}"; then
    if [ -! -d "${HOME}/.atom/packages/atom-beautify/" ]; then
      pip3 install beautysh
      apm install atom-beautify
    fi
  fi
}

# Installing software applications with different package formats and methods
#
# Usage:
#   cmd_install --app [packagename] --flat [LOCATION/REMOTE] --snap --pack
#
# Return:
#   Installed package with the given method(s).
#
_HELP[install]=$(cat << HELPINTSALL
The \`install\` command installs a package on the system.
Use --app to set the package name when installing.

  Usage:
    $(basename "${0}") install [options] [<arguments]

  Options:
    -a, --app          Name of package
    -p, --pack         Install software from main repository (apt-get)
    -r, --repo         Add repository to sources list
    -k, --key          Download and add key to package installation
    -d, --deb          Download the package as .deb and install using dpkg
    -s, --snap         Install software using Snap package management
    -f, --flat         Install software using Flatpak package management
        --ppa          Install packages from PPAs
        --appimg       Download AppImage
        --set          Settings after installation
        --fun          Install package with custom function
    -h, --help         Display this help
        --debug        Run debug mode
HELPINTSALL
)

cmd_install() {

  _PACK="" # (required) --app option argument
  _APP_SETTING=() # Settings into array variable

  # Options parser
  _OPTS_INSTALL=$(getopt --options ha:pr:k:d:s::f: --long help,app:,pack,repo:,key:,deb:,snap::,flat:,appimg:,ppa:,set:,fun:,classic --name "$(basename "${0}") ${_CMD}" -- "${@}")
  if [ $? != 0 ] ; then _error "invalid option(s)" ; fi
  eval set -- "${_OPTS_INSTALL}"

  while true; do
    case "${1}" in
      -h|--help) cmd_help ${_CMD}; shift ;;
      --debug) set -x ; _DEBUG=true ; shift ;;
      -a|--app) _PACK=${2}
        shift 2 ;;
      -p|--pack)
        sudo apt install -y ${_PACK}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift ;;
      --d|-deb) _DEB_ARGS=${2}
        if [[ $(_check_package_exists "${_PACK}") != 0 ]]; then
          wget ${_DEB_ARGS} -O /tmp/${_PACK}.deb
          if [[ "${?}" -ne 0 ]]; then
            _SCRIPT_MESSAGES+=("There is something wrong with the downloading of \`${_DEB_ARGS}\`.")
          fi
          sudo dpkg -i /tmp/${_PACK}.deb
          sudo apt install -fy
        fi
        shift 2 ;;
      -r|--repo) _REPO_ARGS=${2}
        if [[ ! -f "/etc/apt/sources.list.d/${_PACK}.list" ]]; then
          echo "${_REPO_ARGS}" | sudo tee /etc/apt/sources.list.d/${_PACK}.list
        fi
        shift 2 ;;
      -k|--key) _KEY_ARGS=${2}
        wget -q "${_KEY_ARGS}" -O- | sudo apt-key add -
        sudo apt update -qq
        cmd_install --pack ${_PACK}
        shift 2 ;;
      -s|--snap) _SNAP_ARGS=${2}
        if [[ $(_check_package_exists "snapd") != 0 ]]; then
          sudo apt install -y snapd
        fi
        snap install ${_PACK} ${_SNAP_ARGS}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift 2 ;;
      --classic)
        # This option (classic) is only a snap hack, so it can be use as an install argument...
        shift ;;
      -f|--flat) _FLAT_ARGS=${2}
        if [[ $(_check_package_exists "flatpak") != 0 ]]; then
          sudo apt install -y flatpak gnome-software-plugin-flatpak
          flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
          _SCRIPT_MESSAGES+=("After first installation of Flatpak is recommend\nrestart your system to complete setup.")
        fi
        flatpak install --assumeyes flathub ${_FLAT_ARGS}
        if [[ "${?}" -ne 0 ]]; then
          _SCRIPT_MESSAGES+=("There is something wrong with the installation of \`${_PACK}\`.")
        fi
        shift 2 ;;
      --appimg) _APPIMG_ARGS=${2}
        # AppImag location
        if [[ ! -d "${HOME}/.local/bin/" ]]; then
          mkdir -p ${HOME}/.local/bin/
        fi
        # Make location executable
        if [[ ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
          if [[ $(cat ~/.bashrc | grep "export PATH" &> /dev/null; echo $?) -eq 0 ]]; then
            sed -i "s|^export PATH=.*|export PATH=${PATH}:${HOME}/.local/bin|" ~/.bashrc
          else
            echo "export PATH=${PATH}:${HOME}/.local/bin" >> ~/.bashrc
          fi
          # Current session && Next ones
          export PATH=${PATH}:${HOME}/.local/bin && source ~/.bashrc && printf "Updated source...\n"
        fi
        # Get AppImage
        if [[ $(_check_package_exists "${_PACK}") != 0 ]]; then
          wget "${_APPIMG_ARGS}" -O ${HOME}/.local/bin/${_PACK}
          if [[ "${?}" -ne 0 ]]; then
            rm ${HOME}/.local/bin/"${1}"
            _SCRIPT_MESSAGES+=("There is something wrong with the downloading of \`${_DEB_ARGS}\`.")
          fi
          chmod a+x ${HOME}/.local/bin/${_PACK}
        fi
        # AppImage Launcher
        if [ ! -f "$HOME/.local/share/applications/${_PACK}.desktop" ]; then
          _create_desktop_entry "${_PACK}"
        fi
        shift 2 ;;
      --ppa) _PPA_ARGS=${2}
        shift 2 ;;
      --fun) _FUN_ARGS=${2}
        ${_FUN_ARGS}
        shift 2 ;;
      --set) _SET_ARGS=${2}
        _APP_SETTING+=( "${_SET_ARGS}" )
        shift 2 ;;
      --) shift ; break ;;
      *) _error "internal option error '${1}'" ;;
    esac
  done

  if [[ "${_OPTS_INSTALL}" == " --" ]]; then
    cmd_help "${_CMD}"
  fi

  # Run settings
  _setting_app
}

# Call the `_main` function after everything has been defined
#
_main "$@"
